<!doctype html><html lang=ru class=no-js><head><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/architecture/><link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/architecture/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/architecture/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/architecture/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/architecture/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/architecture/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/architecture/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.82.0"><link rel=canonical type=text/html href=https://kubernetes.io/ru/docs/concepts/architecture/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Кластерная Архитектура | Kubernetes</title><meta property="og:title" content="Кластерная Архитектура"><meta property="og:description" content="The architectural concepts behind Kubernetes.
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Кластерная Архитектура"><meta itemprop=description content="The architectural concepts behind Kubernetes.
"><meta name=twitter:card content="summary"><meta name=twitter:title content="Кластерная Архитектура"><meta name=twitter:description content="The architectural concepts behind Kubernetes.
"><link rel=preload href=/scss/main.min.a4bbbf4cec44bb587f51c9896c6b721ca3ded0a7e145b8a5941d804afbcc0c8d.css as=style><link href=/scss/main.min.a4bbbf4cec44bb587f51c9896c6b721ca3ded0a7e145b8a5941d804afbcc0c8d.css rel=stylesheet integrity><script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="The architectural concepts behind Kubernetes.
"><meta property="og:description" content="The architectural concepts behind Kubernetes.
"><meta name=twitter:description content="The architectural concepts behind Kubernetes.
"><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/architecture/"><meta property="og:title" content="Кластерная Архитектура"><meta name=twitter:title content="Кластерная Архитектура"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/script.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ru/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ru/docs/>Документация</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/community/>Сообщество</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/case-studies/>Примеры использования</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ru/docs/concepts/architecture/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Русский</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/architecture/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/architecture/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/architecture/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/architecture/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français</a>
<a class=dropdown-item href=/it/docs/concepts/architecture/>Italiano</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español</a>
<a class=dropdown-item href=/pt-br/docs/concepts/architecture/>Português</a>
<a class=dropdown-item href=/id/docs/concepts/architecture/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/ru/docs/concepts/architecture/>Return to the regular view of this page</a>.</p></div><h1 class=title>Кластерная Архитектура</h1><div class=lead>The architectural concepts behind Kubernetes.</div><ul><li>1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Узлы</a></li><li>2: <a href=#pg-c0251def6da29b30afebfb04549f1703>Связь между плоскостью управления и узлом</a></li><li>3: <a href=#pg-ca8819042a505291540e831283da66df>Контроллеры</a></li><li>4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Диспетчер облочных контроллеров</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>1 - Узлы</h1><p>Kubernetes запускает ваши приложения, помещая контейнеры в Поды для запуска на Узлах (<em>Nodes</em>).
В зависимости от кластера, узел может быть виртуальной или физической машиной. Каждый узел
содержит сервисы, необходимые для запуска
<a class=glossary-tooltip title="Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Подов>Подов</a>, управляемых
<a class=glossary-tooltip title="Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров." data-toggle=tooltip data-placement=top href="/ru/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="плоскостью управления">плоскостью управления</a>.</p><p>Обычно у вас есть несколько узлов в кластере; однако в среде обучения или среде
с ограниченными ресурсами у вас может быть только один.</p><p><a href=/ru/docs/concepts/overview/components/##%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>Компоненты</a> на узле включают
<a class=glossary-tooltip title="Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>,
<a class=glossary-tooltip title="Среда выполнения контейнера — это программа, предназначенная для выполнения контейнеров." data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label="среду выполнения контейнера">среду выполнения контейнера</a> и
<a class=glossary-tooltip title="kube-proxy — сетевой прокси, работающий на каждом узле в кластере." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>.</p><h2 id=управление>Управление</h2><p>Существует два основных способа добавления Узлов в <a class=glossary-tooltip title="Компонент панели управления, обслуживающий API Kubernetes." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label="API сервер">API сервер</a>:</p><ol><li>Kubelet на узле саморегистрируется в плоскости управления</li><li>Вы или другой пользователь вручную добавляете объект Узла</li></ol><p>После того, как вы создадите объект Узла или kubelet на узле самозарегистируется,
плоскость управления проверяет, является ли новый объект Узла валидным (правильным). Например, если вы
попробуете создать Узел при помощи следующего JSON манифеста:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
    }
  }
}
</code></pre></div><p>Kubernetes создает внутри себя объект Узла (представление). Kubernetes проверяет,
что kubelet зарегистрировался на API сервере, который совпадает с значением поля <code>metadata.name</code> Узла.
Если узел здоров (если все необходимые сервисы запущены),
он имеет право на запуск Пода. В противном случае, этот узел игнорируется для любой активности кластера
до тех пор, пока он не станет здоровым.</p><blockquote class="note callout"><div><strong>Заметка:</strong><p>Kubernetes сохраняет объект для невалидного Узла и продолжает проверять, становится ли он здоровым.</p><p>Вы или <a class=glossary-tooltip title="Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллер>контроллер</a> должны явно удалить объект Узла, чтобы
остановить проверку доступности узла.</p></div></blockquote><p>Имя объекта Узла дожно быть валидным
<a href=/ru/docs/concepts/overview/working-with-objects/names#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D0%BF%D0%BE%D0%B4%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2-dns>именем поддомена DNS</a>.</p><h3 id=саморегистрация-узлов>Саморегистрация Узлов</h3><p>Когда kubelet флаг <code>--register-node</code> имеет значение <em>true</em> (по умолчанию), то kubelet будет пытаться
зарегистрировать себя на API сервере. Это наиболее предпочтительная модель, используемая большиством дистрибутивов.</p><p>Для саморегистрации kubelet запускается со следующими опциями:</p><ul><li><p><code>--kubeconfig</code> - Путь к учетным данным для аутентификации на API сервере.</p></li><li><p><code>--cloud-provider</code> - Как общаться с <a class=glossary-tooltip title="Организация, которая предлагает платформу облачных вычислений." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/cloud-providers target=_blank aria-label="облачным провайдером">облачным провайдером</a>, чтобы прочитать метаданные о себе.</p></li><li><p><code>--register-node</code> - Автоматически зарегистрироваться на API сервере.</p></li><li><p><code>--register-with-taints</code> - Зарегистрировать узел с приведенным списком <a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label="ограничений (taints)">ограничений (taints)</a> (разделенных запятыми <code>&lt;key>=&lt;value>:&lt;effect></code>).</p><p>Ничего не делает, если <code>register-node</code> - <em>false</em>.</p></li><li><p><code>--node-ip</code> - IP-адрес узла.</p></li><li><p><code>--node-labels</code> - <a class=glossary-tooltip title="Группирует объекты на основе произвольных критериев, по которым пользователи могут их идентифицировать." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Метки>Метки</a> для добавления при регистрации узла в кластере (смотрите ограничения для меток, установленные <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагином согласования (admission plugin) NodeRestriction</a>).</p></li><li><p><code>--node-status-update-frequency</code> - Указывает, как часто kubelet отправляет статус узла мастеру.</p></li></ul><p>Когда <a href=/docs/reference/access-authn-authz/node/>режим авторизации Узла</a> и
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагин согласования NodeRestriction</a> включены,
kubelet'ы имеют право только создавать/изменять свой собственный ресурс Узла.</p><h3 id=ручное-администрирование-узла>Ручное администрирование узла</h3><p>Вы можете создавать и изменять объекты узла используя
<a class=glossary-tooltip title="A command line tool for communicating with a Kubernetes API server." data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>.</p><p>Когда вы хотите создать объекты Узла вручную, установите kubelet флаг <code>--register-node=false</code>.</p><p>Вы можете изменять объекты Узла независимо от настройки <code>--register-node</code>.
Например, вы можете установить метки на существующем Узле или пометить его неназначаемым.</p><p>Вы можете использовать метки на Узлах в сочетании с селекторами узла на Подах для управления планированием.
Например, вы можете ограничить Под иметь право на запуск только на группе доступных узлов.</p><p>Маркировка узла как неназначаемого предотвращает размещение планировщиком новых подов на этом Узле,
но не влияет на существующие Поды на Узле. Это полезно в качестве
подготовительного шага перед перезагрузкой узла или другим обслуживанием.</p><p>Чтобы отметить Узел неназначемым, выполните:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</code></pre></div><blockquote class="note callout"><div><strong>Заметка:</strong> Поды, являющиеся частью <a class=glossary-tooltip title="Гарантирует, что копия Pod выполняется в наборе узлов кластера." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a> допускают
запуск на неназначаемом Узле. DaemonSets обычно обеспечивает локальные сервисы узла,
которые должны запускаться на Узле, даже если узел вытесняется для запуска приложений.</div></blockquote><h2 id=статус-узла>Статус Узла</h2><p>Статус узла содержит следующие данные:</p><ul><li><a href=#%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0>Адреса (Addresses)</a></li><li><a href=#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5>Условия (Conditions)</a></li><li><a href=#%D0%B5%D0%BC%D0%BA%D0%BE%D1%81%D1%82%D1%8C>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</a></li><li><a href=#%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F>Информация (Info)</a></li></ul><p>Вы можете использовать <code>kubectl</code> для просмотра статуса Узла и других деталей:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node &lt;insert-node-name-here&gt;
</code></pre></div><p>Каждая секция из вывода команды описана ниже.</p><h3 id=адреса-addresses>Адреса (Addresses)</h3><p>Использование этих полей варьируется в зависимости от вашего облачного провайдера или конфигурации физических серверов (<em>bare metal</em>).</p><ul><li>HostName: Имя хоста, сообщаемое ядром узла. Может быть переопределено через kubelet <code>--hostname-override</code> параметр.</li><li>ExternalIP: Обычно, IP адрес узла, который является внешне маршрутизируемым (доступен за пределами кластера).</li><li>InternalIP: Обычно, IP адрес узла, который маршрутизируется только внутри кластера.</li></ul><h3 id=условие>Условия (Conditions)</h3><p>Поле <code>conditions</code> описывает статус всех <code>Running</code> узлов. Примеры условий включают в себя:</p><table><caption style=display:none>Условия узла и описание того, когда применяется каждое условие.</caption><thead><tr><th>Условие Узла</th><th>Описание</th></tr></thead><tbody><tr><td><code>Ready</code></td><td><code>True</code> если узел здоров и готов принять поды, <code>False</code> если узел нездоров и не принимает поды, и <code>Unknown</code> если контроллер узла не получал информацию от узла в течение последнего периода <code>node-monitor-grace-period</code> (по умолчанию 40 секунд)</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> если присутствует давление на размер диска - то есть, если емкость диска мала; иначе <code>False</code></td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> если существует давление на память узла - то есть, если памяти на узле мало; иначе <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> если существует давление на процессы - то есть, если на узле слишком много процессов; иначе <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> если сеть для узла настроена некорректно, иначе <code>False</code></td></tr></tbody></table><blockquote class="note callout"><div><strong>Заметка:</strong> Если вы используете инструменты командной строки для вывода сведений об блокированном узле,
то Условие включает <code>SchedulingDisabled</code>. <code>SchedulingDisabled</code> не является Условием в Kubernetes API;
вместо этого блокированные узлы помечены как Неназначемые в их спецификации.</div></blockquote><p>Состояние узла представлено в виде JSON объекта. Например, следующая структура описывает здоровый узел:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
  {
    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
  }
]
</code></pre></div><p>Если значение параметра Status для условия Ready остается <code>Unknown</code> или <code>False</code>
дольше чем период <code>pod-eviction-timeout</code>(аргумент, переданный в
<a class=glossary-tooltip title="Компонент Control Plane запускает процессы контроллера." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>), то все Поды
на узле планируются к удалению контроллером узла. По умолчанию таймаут выселения <strong>пять минут</strong>.
В некоторых случаях, когда узел недоступен, API сервер не может связаться с kubelet на узле.
Решение об удалении подов не может быть передано в kubelet до тех пор, пока связь с API сервером не будет восстановлена.
В то же время поды, которые запланированы к удалению, могут продолжать работать на отделенном узле.</p><p>Контроллер узла не будет принудительно удалять поды до тех пор, пока не будет подтверждено,
что они перестали работать в кластере. Вы можете видеть, что поды, которые могут работать на недоступном узле,
находятся в состоянии <code>Terminating</code> или <code>Unknown</code>. В тех случаях, когда Kubernetes не может сделать вывод
из основной инфраструктуры о том, что узел окончательно покинул кластер, администратору кластера может потребоваться
удалить объект узла вручную. Удаление объекта узла из Kubernetes приводит к удалению всех объектов Подов, запущенных
на узле, с API сервера и освобождает их имена.</p><p>Контроллер жизненного цикла узла автоматически создает
<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>ограничения (taints)</a>, которые представляют собой условия.
Планировщик учитывает ограничения Узла при назначении Пода на Узел.
Поды так же могут иметь допуски (tolerations), что позволяет им сопротивляться ограничениям Узла.</p><p>Смотрите раздел <a href=/docs/concepts/configuration/taint-and-toleration/#taint-nodes-by-condition>Ограничить Узлы по Условию</a>
для дополнительной информации.</p><h3 id=емкость>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</h3><p>Описывает ресурсы, доступные на узле: CPU, память и максимальное количество подов,
которые могут быть запланированы на узле.</p><p>Поля в блоке capasity указывают общее количество ресурсов, которые есть на Узле.
Блок allocatable указывает количество ресурсовна Узле,
которые доступны для использования обычными Подами.</p><p>Вы можете прочитать больше о емкости и выделяемых ресурсах, изучая, как <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>зарезервировать вычислительные ресурсы</a> на Узле.</p><h3 id=информация-info>Информация (Info)</h3><p>Описывает общую информацию об узле, такую как версия ядра, версия Kubernetes (версии kubelet и kube-proxy), версия Docker (если используется) и название ОС.
Эта информация соберается Kubelet'ом на узле.</p><h3 id=контроллер-узла>Контроллер узла</h3><p><a class=glossary-tooltip title="Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label="Контроллер ">Контроллер</a> узла является компонентом
плоскости управления Kubernetes, который управляет различными аспектами узлов.</p><p>Контроллер узла играет различные роли в жизни узла. Первая - назначение CIDR-блока узлу
при его регистрации (если включено назначение CIDR).</p><p>Вторая - поддержание в актуальном состоянии внутреннего списка узлов контроллера узла
согласно списку доступных машин облачного провайдера. При работе в облачной среде всякий раз,
когда узел неисправен, контроллер узла запрашивает облачного провайдера, доступна ли
виртуальная машина для этого узла. Если нет, то контроллер узла удаляет узел из
своего списка узлов.</p><p>Третья - это мониторинг работоспособности узлов. Контроллер узла
отвечает за обновление условия NodeReady для NodeStatus на
ConditionUnknown, когда узел становится недоступным (т.е. контроллер узла
по какой-то причине перестает получать сердцебиения (heartbeats) от узла,
например, из-за того, что узел упал), и затем позже выселяет все поды с узла
(используя мягкое (graceful) завершение) если узел продолжает быть недоступным.
(По умолчанию таймауты составляют 40 секунд, чтобы начать сообщать <code>ConditionUnknown</code>,
и 5 минут после, чтобы начать выселять поды.)</p><p>Контроллер узла проверяет состояние каждого узла каждые <code>--node-monitor-period</code> секунд.</p><h4 id=сердцебиения>Сердцебиения</h4><p>Сердцебиения, посылаемые узлами Kubernetes, помогают определить доступность узла.</p><p>Существует две формы сердцебиений: обновление <code>NodeStatus</code> и
<a href=/docs/reference/generated/kubernetes-api/v1.25/#lease-v1-coordination-k8s-io>Lease объект</a>.
Каждый узел имеет связанный с ним Lease объект в <code>kube-node-lease</code>
<a class=glossary-tooltip title="An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Lease - это легковестный ресурс, который улучшает производительность
сердцебиений узла при масштабировании кластера.</p><p>Kubelet отвечает за создание и обновление <code>NodeStatus</code> и Lease объекта.</p><ul><li>Kubelet обновляет <code>NodeStatus</code> либо когда происходит изменение статуса,
либо если в течение настронного интервала обновления не было. По умолчанию
интервал для обновлений <code>NodeStatus</code> составляет 5 минут (намного больше,
чем 40-секундный стандартный таймаут для недоступных узлов).</li><li>Kubelet созадет и затем обновляет свой Lease объект каждый 10 секунд
(интервал обновления по умолчанию). Lease обновления происходят независимо от
<code>NodeStatus</code> обновлений. Если обновление Lease завершается неудачно,
kubelet повторяет попытку с экспоненциальным откатом, начинающимся с 200 миллисекунд и ограниченным 7 секундами.</li></ul><h4 id=надежность>Надежность</h4><p>В большинстве случаев контроллер узла ограничивает скорость выселения
до <code>--node-eviction-rate</code> (по умолчанию 0,1) в секунду, что означает,
что он не выселяет поды с узлов быстрее чем c 1 узела в 10 секунд.</p><p>Поведение выселения узла изменяется, когда узел в текущей зоне доступности
становится нездоровым. Контроллер узла проверяет, какой процент узлов в зоне
нездоров (NodeReady условие в значении ConditionUnknown или ConditiononFalse)
в одно и то же время. Если доля нездоровых узлов не меньше
<code>--unhealthy-zone-threshold</code> (по умолчанию 0.55), то скорость выселения уменьшается:
если кластер небольшой (т.е. количество узлов меньше или равно
<code>--large-cluster-size-threshold</code> - по умолчанию, 50), то выселения прекращаются,
в противном случае скорость выселения снижается до
<code>--secondary-node-eviction-rate</code> (по умолчанию, 0.01) в секунду.</p><p>Причина, по которой эти политики реализуются для каждой зоны доступности, заключается в том,
что одна зона доступности может стать отделенной от мастера, в то время как другие
остаются подключенными. Если ваш кластер не охватывает несколько зон доступности
облачного провайдера, то существует только одна зона доступности (весь кластер).</p><p>Основная причина разнесения ваших узлов по зонам доступности заключается в том,
что приложения могут быть перенесены в здоровые зоны, когда одна из зон полностью
становится недоступной. Поэтому, если все узлы в зоне нездоровы, то контроллер узла
выселяет поды с нормальной скоростью <code>--node-eviction-rate</code>. Крайний случай - когда все зоны
полностью нездоровы (т.е. в кластере нет здоровых узлов). В таком случае
контроллер узла предполагает, что существует некоторая проблема с подключением к мастеру,
и останавеливает все выселения, пока какое-нибудь подключение не будет восстановлено.</p><p>Контроллер узла также отвечает за выселение подов, запущенных на узлах с
<code>NoExecute</code> ограничениями, за исключением тех подов, которые сопротивляются этим ограничениям.
Контроллер узла так же добавляет <a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=ограничения>ограничения</a>
соотвествующие проблемам узла, таким как узел недоступен или не готов. Это означает,
что планировщик не будет размещать поды на нездоровых узлах.</p><blockquote class="caution callout"><div><strong>Внимание:</strong> <code>kubectl cordon</code> помечает узел как 'неназначемый', что имеет побочный эфект от контроллера сервисов,
удаляющего узел из любых списков целей LoadBalancer узла, на которые он ранее имел право,
эффектино убирая входящий трафик балансировщика нагрузки с блокированного узла(ов).</div></blockquote><h3 id=емкость-узла>Емкость узла</h3><p>Объекты узла отслеживают информацию о емкости ресурсов узла (например,
объем доступной памяти и количество CPU).
Узлы, которые <a href=#%D1%81%D0%B0%D0%BC%D0%BE%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%83%D0%B7%D0%BB%D0%BE%D0%B2>самостоятельно зарегистировались</a> сообщают
о свое емкости во время регистрации. Если вы <a href=#%D1%80%D1%83%D1%87%D0%BD%D0%BE%D0%B5-%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%83%D0%B7%D0%BB%D0%B0>вручную</a>
добавляете узел, то вам нужно задать информацию о емкости узла при его добавлении.</p><p><a class=glossary-tooltip title="Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=Планировщик>Планировщик</a> Kubernetes гарантирует,
что для всех Подов на Узле достаточно ресурсов. Планировщик проверяет,
что сумма requests от контейнеров на узле не превышает емкость узла.
Эта сумма requests включает все контейнеры, управляемые kubelet,
но исключает любые контейнеры, запущенные непосредственно средой выполнения контейнера,
а также исключает любые процессы, запущенные вне контроля kubelet.</p><blockquote class="note callout"><div><strong>Заметка:</strong> Если вы явно хотите зарезервировать ресурсы для процессов, не связанныз с Подами, смотрите раздел
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>зарезервировать ресурсы для системных демонов</a>.</div></blockquote><h2 id=топология-узла>Топология узла</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Если вы включили <code>TopologyManager</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>, то kubelet
может использовать подсказки топологии при принятии решений о выделении ресурсов.
Смотрите <a href=/docs/tasks/administer-cluster/topology-manager/>Контроль Политик Управления Топологией на Узле</a>
для дополнительной информации.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про<a href=/ru/docs/concepts/overview/components/#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>компоненты</a> из которых состоит узел.</li><li>Подробнее про <a href=/docs/reference/generated/kubernetes-api/v1.21/#node-v1-core>Определение API для Узла</a>.</li><li>Подробнее про <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Узлы</a>
of the architecture design document.</li><li>Подробнее про <a href=/docs/concepts/configuration/taint-and-toleration/>ограничения и допуски</a>.</li><li>Подробнее про <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling>автомаштабирование кластера</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>2 - Связь между плоскостью управления и узлом</h1><p>Этот документ каталог связь между плоскостью управления (apiserver) и кластером Kubernetes. Цель состоит в том, чтобы позволить пользователям настраивать свою установку для усиления сетевой конфигурации, чтобы кластер мог работать в ненадежной сети (или на полностью общедоступных IP-адресах облачного провайдера).</p><h2 id=связь-между-плоскостью-управления-и-узлом>Связь между плоскостью управления и узлом</h2><p>В Kubernetes имеется API шаблон "hub-and-spoke". Все используемые API из узлов (или которые запускают pod-ы) завершает apiserver. Ни один из других компонентов плоскости управления не предназначен для предоставления удаленных сервисов. Apiserver настроен на прослушивание удаленных подключений через безопасный порт HTTPS. (обычно 443) с одной или несколькими включенными формами <a href=/docs/reference/access-authn-authz/authentication/>идентификации</a> клиена.</p><p>Должна быть включена одна или несколько форм <a href=/docs/reference/access-authn-authz/authorization/>идентификации</a>, особенно если разрешены <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>анонимные запросы</a> или <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>service account tokens</a>.</p><p>Узлы должны быть снабжены общедоступным корневым сертификатом для кластера, чтобы они могли безопасно подключаться к apiserver-у вместе с действительными учетными данными клиента. Хороший подход заключается в том, что учетные данные клиента, предоставляемые kubelet, имеют форму клиентского сертификата. См. Информацию о загрузке Kubelet TLS <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS bootstrapping</a> для автоматической подготовки клиентских сертификатов kubelet.</p><p>pod-ы, которые хотят подключиться к apiserver, могут сделать это безопасно, используя учетную запись службы, чтобы Kubernetes автоматически вводил общедоступный корневой сертификат и действительный токен-носитель в pod при его создании.
Служба <code>kubernetes</code> (в пространстве имен <code>default</code>) is настроен с виртуальным IP-адресом, который перенаправляет (через kube-proxy) к endpoint HTTPS apiserver-а.</p><p>Компоненты уровня управления также взаимодействуют с кластером apiserver-а через защищенный порт.</p><p>В результате режим работы по умолчанию для соединений от узлов и модулей, работающих на узлах, к плоскости управления по умолчанию защищен и может работать в ненадежных и/или общедоступных сетях.</p><h2 id=узел-к-плоскости-управления>Узел к плоскости управления</h2><p>Существуют две пути взаимодействия от плоскости управления (apiserver) к узлам. Первый - от apiserver-а до kubelet процесса, который выполняется на каждом узле кластера. Второй - от apiserver к любому узлу, pod-у или службе через промежуточную функциональность apiserver-а.</p><h3 id=apiserver-в-kubelet>apiserver в kubelet</h3><p>Соединение из apiserver-а к kubelet используются для:</p><ul><li>Извлечения логов с pod-ов.</li><li>Прикрепление (через kubectl) к запущенным pod-ам.</li><li>Обеспечение функциональности переадресации портов kubelet.</li></ul><p>Эти соединения заверщаются в kubelet в endpoint HTTPS. По умолчанию apiserver не проверяет сертификат обслуживания kubelet-ов, что делает соединение подверженным к атаке человек по середине (man-in-the-middle) и <strong>unsafe</strong> запущенных в ненадежных или общедоступных сетях.</p><p>Для проверки этого соединения, используется флаг <code>--kubelet-certificate-authority</code> чтобы предоставить apiserver-у набор корневых (root) сертификатов для проверки сертификата обслуживания kubelet-ов.</p><p>Если это не возможно, используйте <a href=#ssh-tunnels>SSH-тунелирование</a> между apiserver-ом и kubelet, если это необходимо во избежании подключения по ненадежной или общедоступной сети.</p><p>Наконец, Должны быть включены <a href=/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>пудентификация или авторизация Kubelet</a> для защиты kubelet API.</p><h3 id=apiserver-для-узлов-pod-ов-и-служб>apiserver для узлов, pod-ов, и служб</h3><p>Соединение с apiserver-ом к узлу, pod-у или службе по умолчанию осушествяляется по обычному HTTP-соединению и поэтому не проходят проверку подлиности и не шифрование. Они могут быть запущены по защищенному HTTPS-соединению, добавив префикс <code>https:</code> к имени узла, pod-а или службы в URL-адресе API, но они не будут проверять сертификат предоставленный HTTPS endpoint, также не будут предоставлять учетные данные клиента. Таким образом, хотя соединение будет зашифровано, оно не обеспечит никаких гарантий целостности. Эти соединения <strong>are not currently safe</strong> запущенных в ненадежных или общедоступных сетях.</p><h3 id=ssh-тунели>SSH-тунели</h3><p>Kubernetes поддерживает SSH-туннели для защиты плоскости управления узлов от путей связи. В этой конфигурации apiserver инициирует SSH-туннель для каждого узла в кластере (подключается к ssh-серверу, прослушивая порт 22) и передает весь трафикпредназначенный для kubelet, узлу, pod-у или службе через тунель. Этот тунель гарантирует, что трафик не выводиться за пределы сети, в которой работает узел.</p><p>SSH-туннели в настоящее время устарели, поэтому вы не должны использовать их, если не знаете, что делаете. Служба подключения является заменой этого канала связи.</p><h3 id=служба-подключения>Служба подключения</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>В качестве замены SSH-туннелям, служба подключения обеспечивает уровень полномочие TCP для плоскости управления кластерной связи. Служба подключения состоит из двух частей: сервер подключения в сети плоскости управления и агентов подключения в сети узлов. Агенты службы подключения инициируют подключения к серверу подключения и поддерживают сетевое подключение. После включения службы подключения, весь трафик с плоскости управления на узлы проходит через эти соединения.</p><p>Следуйте инструкциям <a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>Задача службы подключения</a> чтобы настроить службу подключения в кластере.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3 - Контроллеры</h1><p>В робототехнике и автоматизации, <em>цикл управления</em> - это непрерывный цикл, который регулирует состояние системы.</p><p>Вот один из примеров контура управления: термостат в помещении.</p><p>Когда вы устанавливаете температуру, это говорит термостату о вашем <em>желаемом состоянии</em>. Фактическая температура в помещении - это
<em>текущее состояние</em>. Термостат действует так, чтобы приблизить текущее состояние к елаемому состоянию, путем включения или выключения оборудования.</p>Контроллеры в Kubernetes - управляющие циклы, которые отслеживают состояние вашего
<a class=glossary-tooltip title="Набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел." data-toggle=tooltip data-placement=top href="/ru/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=кластера>кластера</a>, затем вносят или запрашивают
изменения там, где это необходимо.
Каждый контроллер пытается привести текущее состояние кластера ближе к желаемому состоянию.<h2 id=шаблон-контроллера>Шаблон контроллера</h2><p>Контроллер отслеживает по крайней мере один тип ресурса Kubernetes.
Эти <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>объекты</a>
имеют поле спецификации, которое представляет желаемое состояние. Контроллер (ы) для этого ресурса несут ответственность за приближение текущего состояния к желаемому состоянию</p><p>Контроллер может выполнить это действие сам; чаще всего в Kubernetes,
контроллер будет отправляет сообщения на
<a class=glossary-tooltip title="Компонент панели управления, обслуживающий API Kubernetes." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label="сервер API">сервер API</a> которые имеют
полезные побочные эффекты. Пример этого вы можете увидеть ниже.</p><h3 id=управление-с-помощью-сервера-api>Управление с помощью сервера API</h3><p>Контроллер <a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> является примером встроенного контроллера Kubernetes. Встроенные контроллеры управляют состоянием, взаимодействуя с кластером сервера API.</p><p>Задание - это ресурс Kubernetes, который запускает
<a class=glossary-tooltip title="Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>, или возможно несколько Pod-ов, которые выполняют задание и затем останавливаются.</p><p>(После <a href=/docs/concepts/scheduling-eviction/>планирования</a>, Pod объекты становятся частью желаемого состояния для kubelet).</p><p>Когда контроллер задания видить новую задачу, он убеждается что где-то в вашем кластере kubelet-ы на множестве узлов запускают нужное количество Pod-ов для выполнения работы.
Контроллер задания сам по себе не запускает никакие Pod-ы или контейнеры. Вместо этого контроллер задания Iсообщает серверу API о создании или удалении Pod-ов.
Другие компоненты в
<a class=glossary-tooltip title="Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров." data-toggle=tooltip data-placement=top href="/ru/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="плоскости управления">плоскости управления</a>
действуют на основе информации (имеются ли новые заплонированные Pod-ы для запуска), и в итоге работка заверщается.</p><p>После того, как вы создадите новое задание, желаемое состояние для этого задания будет завершено. Контроллер задания приближает текущее состояние этого задания к желаемому состоянию: создает Pod-ы, которые выполняют работу, которую вы хотели для этого задания, чтобы задание было ближе к завершению.</p><p>Контроллеры также обровляют объекты которые их настраивают.
Например: как только работа выполнена для задания, контроллер задания обновляет этот объект задание, чтобы пометить его как <code>Завершенный</code>.</p><p>(Это немного похоже на то, как некоторые термостаты выключают свет, чтобы указать, что теперь ваша комната имеет установленную вами температуру).</p><h3 id=прямое-управление>Прямое управление</h3><p>В отличие от Задания, некоторым контроллерам нужно вносить изменения в вещи за пределами вашего кластера.</p><p>Например, если вы используете контур управления, чтобы убедиться, что в вашем кластере достаточно <a class=glossary-tooltip title="Узел — рабочая машина в Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Узлов>Узлов</a>,
тогда этому контроллеру нужно что-то вне текущего кластера, чтобы при необъодимости установить новые узлы.</p><p>Контроллеры, которые взаимодействуют с внешним состоянием, находят свое желаемое состояние с сервера API, а затем напрямую взаимодействуют с внешней системой, чтобы приблизить текущее состояние.</p><p>(На самом деле существует <a href=https://github.com/kubernetes/autoscaler/>контроллер</a>
, который горизонтально маштабирует узла в вашем кластере.)</p><p>Важным моментом здесь является то, что контроллер вносит некоторые изменения, чтобы вызвать желаемое состояние, а затем сообщает текущее состояние обратно на сервер API вашего кластера. Другие контуры управления могут наблюдать за этими отчетными данными и предпринимать собственные действия.</p><p>В примере с термостатом, если в помещении очень холодно, тогда другой контроллер может также включить обогреватель для защиты от замерзания. В кластерах Kubernetes, плоскость управления косвенно работает с инструментами управления IP-адресами,службами хранения данных, API облочных провайдеров и другими службами для релизации
<a href=/docs/concepts/extend-kubernetes/>расширения Kubernetes</a>.</p><h2 id=desired-vs-current>Желаемое против текущего состояния</h2><p>Kubernetes использует систему вида cloud-native и способен справлятся с постоянными изменениями.</p><p>Ваш кластер может изменяться в любой по мере выполнения работы и контуры управления автоматически устранают сбой. Это означает, что потенциально Ваш кластер никогда не достигнет стабильного состояния.</p><p>Пока контроллеры вашего кластера работают и могут вносить полезные изменения, не имеет значения, является ли общее состояние стабильным или нет.</p><h2 id=дизайн>Дизайн</h2><p>В качестве принципа своей конструкции Kubernetes использует множество контроллеров, каждый из которых управляет определенным аспектом состояния кластера. Чаще всего конкретный контур управления (контроллер) использует один вид ресурса в качестве своего желаемого состояния и имеет другой вид ресурса, которым он управляет, чтобы это случилось. Например, контроллер для заданий отслеживает объекты заданий (для обнаружения новой работы) и объекты модулей (для выполнения заданий, а затем для того, чтобы видеть, когда работа завершена). В этом случае что-то еще создает задания, тогда как контроллер заданий создает Pod-ы.</p><p>Полезно иметь простые контроллеры, а не один монолитный набор взаимосвязанных контуров управления. Контроллеры могут выйти из строя, поэтому Kubernetes предназначен для этого.</p><blockquote class="note callout"><div><strong>Заметка:</strong><p>Существует несколько контроллеров, которые создают или обновляют один и тот же тип объекта. За кулисами контроллеры Kubernetes следят за тем, чтобы обращать внимание только на ресурсы, связанные с их контролирующим ресурсом.</p><p>Например, у вас могут быть развертывания и задания; они оба создают Pod-ы. Контроллер заданий не удаляет Pod-ы созданные вашим развертиыванием, потому что имеется информационные (<a class=glossary-tooltip title="Группирует объекты на основе произвольных критериев, по которым пользователи могут их идентифицировать." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=метки>метки</a>)
которые могут быть использованы контроллерами тем самым показывая отличие Pod-ов.</p></div></blockquote><h2 id=running-controllers>Способы запуска контроллеров</h2><p>Kubernetes поставляется с набором встроенных контроллеров, которые работают внутри <a class=glossary-tooltip title="Компонент Control Plane запускает процессы контроллера." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. Эти встроенные контроллеры обеспечивают важные основные функции.</p><p>Контроллер развертывания и контроллер заданий - это примеры контроллеров, которые входят в состав самого Kubernetes («встроенные» контроллеры).
Kubernetes позволяет вам запускать устойчивую плоскость управления, так что в случае отказа одного из встроенных контроллеров работу берет на себя другая часть плоскости управления.</p><p>Вы можете найти контроллеры, которые работают вне плоскости управления, чтобы расширить Kubernetes.
Или, если вы хотите, можете написать новый контроллер самостоятельно. Вы можете запустить свой собственный контроллер виде наборов Pod-ов,
или внешнее в Kubernetes. Что подойдет лучше всего, будет зависеть от того, что делает этот конкретный контроллер.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Прочтите о <a href=/docs/concepts/overview/components/#control-plane-components>плоскости управления Kubernetes</a></li><li>Откройте для себя некоторые из основных <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>объектов Kubernetes</a></li><li>Узнайте больше о <a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></li><li>Если вы хотите написать собственный контроллер, см <a href=/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>Шаблоны расширения</a> в расширении Kubernetes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>4 - Диспетчер облочных контроллеров</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>Технологии облочной инфраструктуры позволяет запускать Kubernetes в общедоступных, частных и гибритных облоках. Kubernetes верит в автоматизированную,управляемую API инфраструктуру без жесткой связи между компонентами.</p><p><p>Диспетчер облочных контроллеров компонент <a class=glossary-tooltip title="Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров." data-toggle=tooltip data-placement=top href="/ru/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="панель управления">панель управления</a> Kubernetes - это встраиваемый в логику управления облочная спецификация. Диспетчер облачных контроллеров позволяет связать кластер с API поставщика облачных услуг и отделить компоненты, взаимодействующие с этой облачной платформой, от компонентов, взаимодействующих только с вашим кластером.</p></p><p>Отделяя логику взаимодействия между Kubernetes и базовой облачной инфраструктурой, компонент cloud-controller-manager позволяет поставщикам облачных услуг выпускать функции в другом темпе по сравнению с основным проектом Kubernetes.</p><p>Диспетчер облочных контроллеров структурирован с использованием механизма плагинов, которые позволяют различным облочным провайдерам интегрировать свои платформы с Kubernetes.</p><h2 id=дизайн>Дизайн</h2><p><img src=/images/docs/components-of-kubernetes.svg alt="Kubernetes components"></p><p>Диспетчер облочных контроллеров работает в панели управления как реплицированный набот процессов (обычно это контейнер в Pod-ах). Каждый диспетчер облочных контроллеров реализует многоразовые <a class=glossary-tooltip title="Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллеры>контроллеры</a> в единственном процессе.</p><blockquote class="note callout"><div><strong>Заметка:</strong> Вы так же можете запустить диспетчер облочных контроллеров как <a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=дополнение>дополнение</a> Kubernetes, а некак часть панели управления.</div></blockquote><h2 id=functions-of-the-ccm>Функции диспетчера облочных контроллеров</h2><p>Контроллеры внутри диспетчера облочных контроллеров включают в себя:</p><h3 id=контролер-узла>Контролер узла</h3><p>Контроллер узла отвечает за создание объектов <a class=glossary-tooltip title="Узел — рабочая машина в Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=узла>узла</a> при создании новых серверов в вашей облочной инфраструктуре. Контроллер узла получает информацию
о работающих хостах внутри вашего арендуемого облочного провайдера.
Контроллер узла выполняет следующие функции:</p><ol><li>Инициализация объектов узла для каждого сервера, контроллер которого через API облочного провайдера.</li><li>Аннотирование и маркировка объеко узла специфичной для облока информацией, такой как регион, в котором развернут узел и доступные ему ресурсы (процессор, память и т.д.).</li><li>Получение имени хоста и сетевых адресов.</li><li>Проверка работоспособности ущла. В случае, если узел перестает отвечать на запросы, этот контроллер проверяется с помощью API вашего облочного провайдера, был ли сервер деактевирован / удален / прекращен.
Если узел был удален из облока, контроллер удлаяет объект узла из вашего Kubernetes кластера..</li></ol><p>Некоторые облочные провайдеры реализуют его разделение на контроллер узла и отдельный контроллер жизненного цикла узла.</p><h3 id=контролер-маршрута>Контролер маршрута</h3><p>Контролер маршрута отвечае за соответствующую настройку маршрутов облоке, чтобы контейнеры на разных узлах кластера Kubernetes могли взаимодействовать друг с другом.</p><p>В зависимости от облочного провайдера, контроллер маршрута способен также выделять блоки IP адресов для сети Pod.</p><h3 id=сервисный-контроллер>Сервисный контроллер</h3><p><a class=glossary-tooltip title="Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Службы>Службы</a> интегрируются с компонентами облочной инфраструктуры, такими как управляемые балансировщики нагрузки, IP адреса, фильтрация сетевых пакетов и проверка работоспособности целевых объектов. Сервисный контроллер взаимодействует с API вашего облочного провайдера для настройки балансировщиков нагрузки и других компонентов инфраструктуры, когда вы объявляете ресурсные службы которые он требует.</p><h2 id=авторизация>Авторизация</h2><p>В этом разделе разбирается доступ, который нужен для управления облочным контроллером к различным объектам API для выполнения своих операций.</p><h3 id=authorization-node-controller>Контроллер узла</h3><p>Контроллер узла работает только с объектом узла. Он требует полного доступа для и изменения объектов узла.</p><p><code>v1/Node</code>:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=authorization-route-controller>Контролер маршрута</h3><p>Контролер маршрута прослушивает создание объектов узла и соответствующим образом настраивает маршруты. Для этого требуется получить доступ к объектам узла.</p><p><code>v1/Node</code>:</p><ul><li>Get</li></ul><h3 id=authorization-service-controller>Сервисный контроллер</h3><p>Сервисный контроллер прослушивает события Create, Update и Delete объектов службы, а затем соответствующим образом настраивает конечные точки для этих соответствующих сервисов.</p><p>Для доступа к сервисам, требуется доступ к событиям List и Watch. Для обновления сервисов, требуется доступ к событиям Patch и Update.</p><p>Чтобы настроить ресурсы конечных точек для сервисов, требуется доступ к событиям Create, List, Get, Watch, и Update.</p><p><code>v1/Service</code>:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=authorization-miscellaneous>Другие</h3><p>Реализация ядра диспетчера облочных контроллеров требует доступ для создания создания объектов события, а для обеспечения безопасной работы требуется доступ для создания учетных записей сервисов (ServiceAccounts).</p><p><code>v1/Event</code>:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p><code>v1/ServiceAccount</code>:</p><ul><li>Create</li></ul><p>The <a class=glossary-tooltip title="Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRole для диспетчера облочных контроллеров выглядить так:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></code></pre></div><h2 id=что-дальше>Что дальше</h2><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Администрирование диспетчера облочных контроллеров</a>
содержить инструкции по запуску и управлению диспетером облочных контроллеров.</p><p>Хотите знать как реализовать свой собственный диспетчер облочных контроллеров или расширить проект?</p><p>Диспетчер облочных контроллеров использует интерфейс Go, который позволяет реализовать подключение из любого облока. В частности, он использует <code>CloudProvider</code> интерфейс, который определен в <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.17/cloud.go#L42-L62><code>cloud.go</code></a> из <a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>.</p><p>Реализация общих контроллеров выделенных в этом документе (Node, Route, и Service),а так же некоторые возведения вместе с общим облочным провайдерским интерфейсом являются частью ядра Kubernetes. особые реализации, для облочных провайдеров находятся вне ядра Kubernetes и реализуют интерфейс <code>CloudProvider</code>.</p><p>Дополнительные сведения о разработке плагинов см. в разделе <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Разработка диспетчера облочных контроллеров</a>.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ru/docs/home/>Главная</a>
<a class=text-white href=/ru/community/>Сообщество</a>
<a class=text-white href=/ru/case-studies/>Примеры использования</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Авторы Kubernetes | Документация распространяется под лицензией <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Все права защищены. The Linux Foundation является зарегистрированной торговой маркой. Список торговых марок The Linux Foundation приведен на странице <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>использования торговых марок</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script></body></html>