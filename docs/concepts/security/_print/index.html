<!doctype html><html lang=en class=no-js><head><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script><link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/security/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/security/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/security/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/security/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/security/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/security/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/security/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.82.0"><link rel=canonical type=text/html href=https://kubernetes.io/docs/concepts/security/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Security | Kubernetes</title><meta property="og:title" content="Security"><meta property="og:description" content="Concepts for keeping your cloud-native workload secure.
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/docs/concepts/security/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Security"><meta itemprop=description content="Concepts for keeping your cloud-native workload secure.
"><meta name=twitter:card content="summary"><meta name=twitter:title content="Security"><meta name=twitter:description content="Concepts for keeping your cloud-native workload secure.
"><link rel=preload href=/scss/main.min.a4bbbf4cec44bb587f51c9896c6b721ca3ded0a7e145b8a5941d804afbcc0c8d.css as=style><link href=/scss/main.min.a4bbbf4cec44bb587f51c9896c6b721ca3ded0a7e145b8a5941d804afbcc0c8d.css rel=stylesheet integrity><script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Concepts for keeping your cloud-native workload secure.
"><meta property="og:description" content="Concepts for keeping your cloud-native workload secure.
"><meta name=twitter:description content="Concepts for keeping your cloud-native workload secure.
"><meta property="og:url" content="https://kubernetes.io/docs/concepts/security/"><meta property="og:title" content="Security"><meta name=twitter:title content="Security"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/script.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/docs/>Documentation</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/blog/>Kubernetes Blog</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/training/>Training</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/partners/>Partners</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/community/>Community</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/case-studies/>Case Studies</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/concepts/security/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/concepts/security/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/concepts/security/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/concepts/security/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/docs/concepts/security/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh/docs/concepts/security/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/security/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/security/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/security/>Français</a>
<a class=dropdown-item href=/pt-br/docs/concepts/security/>Português</a>
<a class=dropdown-item href=/es/docs/concepts/security/>Español</a>
<a class=dropdown-item href=/id/docs/concepts/security/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/concepts/security/>Return to the regular view of this page</a>.</p></div><h1 class=title>Security</h1><div class=lead>Concepts for keeping your cloud-native workload secure.</div><ul><li>1: <a href=#pg-04eeb110d75afc8acb2cf7a3db743985>Overview of Cloud Native Security</a></li><li>2: <a href=#pg-1fb24c1dd155f43849da490a74c4b8c5>Pod Security Standards</a></li><li>3: <a href=#pg-4d77d1ae4c06aa14f54b385191627881>Controlling Access to the Kubernetes API</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-04eeb110d75afc8acb2cf7a3db743985>1 - Overview of Cloud Native Security</h1><p>This overview defines a model for thinking about Kubernetes security in the context of Cloud Native security.</p><blockquote class="warning callout"><div><strong>Warning:</strong> This container security model provides suggestions, not proven information security policies.</div></blockquote><h2 id=the-4c-s-of-cloud-native-security>The 4C's of Cloud Native security</h2><p>You can think about security in layers. The 4C's of Cloud Native security are Cloud,
Clusters, Containers, and Code.</p><blockquote class="note callout"><div><strong>Note:</strong> This layered approach augments the <a href=https://en.wikipedia.org/wiki/Defense_in_depth_(computing)>defense in depth</a>
computing approach to security, which is widely regarded as a best practice for securing
software systems.</div></blockquote><figure><img src=/images/docs/4c.png><figcaption><h4>The 4C's of Cloud Native Security</h4></figcaption></figure><p>Each layer of the Cloud Native security model builds upon the next outermost layer.
The Code layer benefits from strong base (Cloud, Cluster, Container) security layers.
You cannot safeguard against poor security standards in the base layers by addressing
security at the Code level.</p><h2 id=cloud>Cloud</h2><p>In many ways, the Cloud (or co-located servers, or the corporate datacenter) is the
<a href=https://en.wikipedia.org/wiki/Trusted_computing_base>trusted computing base</a>
of a Kubernetes cluster. If the Cloud layer is vulnerable (or
configured in a vulnerable way) then there is no guarantee that the components built
on top of this base are secure. Each cloud provider makes security recommendations
for running workloads securely in their environment.</p><h3 id=cloud-provider-security>Cloud provider security</h3><p>If you are running a Kubernetes cluster on your own hardware or a different cloud provider,
consult your documentation for security best practices.
Here are links to some of the popular cloud providers' security documentation:</p><table><caption style=display:none>Cloud provider security</caption><thead><tr><th>IaaS Provider</th><th>Link</th></tr></thead><tbody><tr><td>Alibaba Cloud</td><td><a href=https://www.alibabacloud.com/trust-center>https://www.alibabacloud.com/trust-center</a></td></tr><tr><td>Amazon Web Services</td><td><a href=https://aws.amazon.com/security/>https://aws.amazon.com/security/</a></td></tr><tr><td>Google Cloud Platform</td><td><a href=https://cloud.google.com/security/>https://cloud.google.com/security/</a></td></tr><tr><td>IBM Cloud</td><td><a href=https://www.ibm.com/cloud/security>https://www.ibm.com/cloud/security</a></td></tr><tr><td>Microsoft Azure</td><td><a href=https://docs.microsoft.com/en-us/azure/security/azure-security>https://docs.microsoft.com/en-us/azure/security/azure-security</a></td></tr><tr><td>VMWare VSphere</td><td><a href=https://www.vmware.com/security/hardening-guides.html>https://www.vmware.com/security/hardening-guides.html</a></td></tr></tbody></table><h3 id=infrastructure-security>Infrastructure security</h3><p>Suggestions for securing your infrastructure in a Kubernetes cluster:</p><table><caption style=display:none>Infrastructure security</caption><thead><tr><th>Area of Concern for Kubernetes Infrastructure</th><th>Recommendation</th></tr></thead><tbody><tr><td>Network access to API Server (Control plane)</td><td>All access to the Kubernetes control plane is not allowed publicly on the internet and is controlled by network access control lists restricted to the set of IP addresses needed to administer the cluster.</td></tr><tr><td>Network access to Nodes (nodes)</td><td>Nodes should be configured to <em>only</em> accept connections (via network access control lists)from the control plane on the specified ports, and accept connections for services in Kubernetes of type NodePort and LoadBalancer. If possible, these nodes should not be exposed on the public internet entirely.</td></tr><tr><td>Kubernetes access to Cloud Provider API</td><td>Each cloud provider needs to grant a different set of permissions to the Kubernetes control plane and nodes. It is best to provide the cluster with cloud provider access that follows the <a href=https://en.wikipedia.org/wiki/Principle_of_least_privilege>principle of least privilege</a> for the resources it needs to administer. The <a href=https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles>Kops documentation</a> provides information about IAM policies and roles.</td></tr><tr><td>Access to etcd</td><td>Access to etcd (the datastore of Kubernetes) should be limited to the control plane only. Depending on your configuration, you should attempt to use etcd over TLS. More information can be found in the <a href=https://github.com/etcd-io/etcd/tree/master/Documentation>etcd documentation</a>.</td></tr><tr><td>etcd Encryption</td><td>Wherever possible it's a good practice to encrypt all drives at rest, but since etcd holds the state of the entire cluster (including Secrets) its disk should especially be encrypted at rest.</td></tr></tbody></table><h2 id=cluster>Cluster</h2><p>There are two areas of concern for securing Kubernetes:</p><ul><li>Securing the cluster components that are configurable</li><li>Securing the applications which run in the cluster</li></ul><h3 id=cluster-components>Components of the Cluster</h3><p>If you want to protect your cluster from accidental or malicious access and adopt
good information practices, read and follow the advice about
<a href=/docs/tasks/administer-cluster/securing-a-cluster/>securing your cluster</a>.</p><h3 id=cluster-applications>Components in the cluster (your application)</h3><p>Depending on the attack surface of your application, you may want to focus on specific
aspects of security. For example: If you are running a service (Service A) that is critical
in a chain of other resources and a separate workload (Service B) which is
vulnerable to a resource exhaustion attack then the risk of compromising Service A
is high if you do not limit the resources of Service B. The following table lists
areas of security concerns and recommendations for securing workloads running in Kubernetes:</p><table><thead><tr><th>Area of Concern for Workload Security</th><th>Recommendation</th></tr></thead><tbody><tr><td>RBAC Authorization (Access to the Kubernetes API)</td><td><a href=https://kubernetes.io/docs/reference/access-authn-authz/rbac/>https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a></td></tr><tr><td>Authentication</td><td><a href=https://kubernetes.io/docs/concepts/security/controlling-access/>https://kubernetes.io/docs/concepts/security/controlling-access/</a></td></tr><tr><td>Application secrets management (and encrypting them in etcd at rest)</td><td><a href=https://kubernetes.io/docs/concepts/configuration/secret/>https://kubernetes.io/docs/concepts/configuration/secret/</a><br><a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</a></td></tr><tr><td>Pod Security Policies</td><td><a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/>https://kubernetes.io/docs/concepts/policy/pod-security-policy/</a></td></tr><tr><td>Quality of Service (and Cluster resource management)</td><td><a href=https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/>https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/</a></td></tr><tr><td>Network Policies</td><td><a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>https://kubernetes.io/docs/concepts/services-networking/network-policies/</a></td></tr><tr><td>TLS For Kubernetes Ingress</td><td><a href=https://kubernetes.io/docs/concepts/services-networking/ingress/#tls>https://kubernetes.io/docs/concepts/services-networking/ingress/#tls</a></td></tr></tbody></table><h2 id=container>Container</h2><p>Container security is outside the scope of this guide. Here are general recommendations and
links to explore this topic:</p><table><thead><tr><th>Area of Concern for Containers</th><th>Recommendation</th></tr></thead><tbody><tr><td>Container Vulnerability Scanning and OS Dependency Security</td><td>As part of an image build step, you should scan your containers for known vulnerabilities.</td></tr><tr><td>Image Signing and Enforcement</td><td>Sign container images to maintain a system of trust for the content of your containers.</td></tr><tr><td>Disallow privileged users</td><td>When constructing containers, consult your documentation for how to create users inside of the containers that have the least level of operating system privilege necessary in order to carry out the goal of the container.</td></tr><tr><td>Use container runtime with stronger isolation</td><td>Select <a href=/docs/concepts/containers/runtime-class/>container runtime classes</a> that provider stronger isolation</td></tr></tbody></table><h2 id=code>Code</h2><p>Application code is one of the primary attack surfaces over which you have the most control.
While securing application code is outside of the Kubernetes security topic, here
are recommendations to protect application code:</p><h3 id=code-security>Code security</h3><table><caption style=display:none>Code security</caption><thead><tr><th>Area of Concern for Code</th><th>Recommendation</th></tr></thead><tbody><tr><td>Access over TLS only</td><td>If your code needs to communicate by TCP, perform a TLS handshake with the client ahead of time. With the exception of a few cases, encrypt everything in transit. Going one step further, it's a good idea to encrypt network traffic between services. This can be done through a process known as mutual or <a href=https://en.wikipedia.org/wiki/Mutual_authentication>mTLS</a> which performs a two sided verification of communication between two certificate holding services.</td></tr><tr><td>Limiting port ranges of communication</td><td>This recommendation may be a bit self-explanatory, but wherever possible you should only expose the ports on your service that are absolutely essential for communication or metric gathering.</td></tr><tr><td>3rd Party Dependency Security</td><td>It is a good practice to regularly scan your application's third party libraries for known security vulnerabilities. Each programming language has a tool for performing this check automatically.</td></tr><tr><td>Static Code Analysis</td><td>Most languages provide a way for a snippet of code to be analyzed for any potentially unsafe coding practices. Whenever possible you should perform checks using automated tooling that can scan codebases for common security errors. Some of the tools can be found at: <a href=https://owasp.org/www-community/Source_Code_Analysis_Tools>https://owasp.org/www-community/Source_Code_Analysis_Tools</a></td></tr><tr><td>Dynamic probing attacks</td><td>There are a few automated tools that you can run against your service to try some of the well known service attacks. These include SQL injection, CSRF, and XSS. One of the most popular dynamic analysis tools is the <a href=https://owasp.org/www-project-zap/>OWASP Zed Attack proxy</a> tool.</td></tr></tbody></table><h2 id=what-s-next>What's next</h2><p>Learn about related Kubernetes security topics:</p><ul><li><a href=/docs/concepts/security/pod-security-standards/>Pod security standards</a></li><li><a href=/docs/concepts/services-networking/network-policies/>Network policies for Pods</a></li><li><a href=/docs/concepts/security/controlling-access>Controlling Access to the Kubernetes API</a></li><li><a href=/docs/tasks/administer-cluster/securing-a-cluster/>Securing your cluster</a></li><li><a href=/docs/tasks/tls/managing-tls-in-a-cluster/>Data encryption in transit</a> for the control plane</li><li><a href=/docs/tasks/administer-cluster/encrypt-data/>Data encryption at rest</a></li><li><a href=/docs/concepts/configuration/secret/>Secrets in Kubernetes</a></li><li><a href=/docs/concepts/containers/runtime-class>Runtime class</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1fb24c1dd155f43849da490a74c4b8c5>2 - Pod Security Standards</h1><p>Security settings for Pods are typically applied by using <a href=/docs/tasks/configure-pod-container/security-context/>security
contexts</a>. Security Contexts allow for the
definition of privilege and access controls on a per-Pod basis.</p><p>The enforcement and policy-based definition of cluster requirements of security contexts has
previously been achieved using <a href=/docs/concepts/policy/pod-security-policy/>Pod Security Policy</a>. A
<em>Pod Security Policy</em> is a cluster-level resource that controls security sensitive aspects of the
Pod specification.</p><p>However, numerous means of policy enforcement have arisen that augment or replace the use of
PodSecurityPolicy. The intent of this page is to detail recommended Pod security profiles, decoupled
from any specific instantiation.</p><h2 id=policy-types>Policy Types</h2><p>There is an immediate need for base policy definitions to broadly cover the security spectrum. These
should range from highly restricted to highly flexible:</p><ul><li><strong><em>Privileged</em></strong> - Unrestricted policy, providing the widest possible level of permissions. This
policy allows for known privilege escalations.</li><li><strong><em>Baseline</em></strong> - Minimally restrictive policy while preventing known privilege
escalations. Allows the default (minimally specified) Pod configuration.</li><li><strong><em>Restricted</em></strong> - Heavily restricted policy, following current Pod hardening best practices.</li></ul><h2 id=policies>Policies</h2><h3 id=privileged>Privileged</h3><p>The Privileged policy is purposely-open, and entirely unrestricted. This type of policy is typically
aimed at system- and infrastructure-level workloads managed by privileged, trusted users.</p><p>The privileged policy is defined by an absence of restrictions. For allow-by-default enforcement
mechanisms (such as gatekeeper), the privileged profile may be an absence of applied constraints
rather than an instantiated policy. In contrast, for a deny-by-default mechanism (such as Pod
Security Policy) the privileged policy should enable all controls (disable all restrictions).</p><h3 id=baseline>Baseline</h3><p>The Baseline policy is aimed at ease of adoption for common containerized workloads while
preventing known privilege escalations. This policy is targeted at application operators and
developers of non-critical applications. The following listed controls should be
enforced/disallowed:</p><table><caption style=display:none>Baseline policy specification</caption><tbody><tr><td><strong>Control</strong></td><td><strong>Policy</strong></td></tr><tr><td>Host Namespaces</td><td>Sharing the host namespaces must be disallowed.<br><br><b>Restricted Fields:</b><br>spec.hostNetwork<br>spec.hostPID<br>spec.hostIPC<br><br><b>Allowed Values:</b> false<br></td></tr><tr><td>Privileged Containers</td><td>Privileged Pods disable most security mechanisms and must be disallowed.<br><br><b>Restricted Fields:</b><br>spec.containers[*].securityContext.privileged<br>spec.initContainers[*].securityContext.privileged<br><br><b>Allowed Values:</b> false, undefined/nil<br></td></tr><tr><td>Capabilities</td><td>Adding <tt>NET_RAW</tt> or capabilities beyond the <a href=https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities>default set</a> must be disallowed.<br><br><b>Restricted Fields:</b><br>spec.containers[*].securityContext.capabilities.add<br>spec.initContainers[*].securityContext.capabilities.add<br><br><b>Allowed Values:</b> empty (or restricted to a known list)<br></td></tr><tr><td>HostPath Volumes</td><td>HostPath volumes must be forbidden.<br><br><b>Restricted Fields:</b><br>spec.volumes[*].hostPath<br><br><b>Allowed Values:</b> undefined/nil<br></td></tr><tr><td>Host Ports</td><td>HostPorts should be disallowed, or at minimum restricted to a known list.<br><br><b>Restricted Fields:</b><br>spec.containers[*].ports[*].hostPort<br>spec.initContainers[*].ports[*].hostPort<br><br><b>Allowed Values:</b> 0, undefined (or restricted to a known list)<br></td></tr><tr><td>AppArmor</td><td>On supported hosts, the 'runtime/default' AppArmor profile is applied by default.
The baseline policy should prevent overriding or disabling the default AppArmor
profile, or restrict overrides to an allowed set of profiles.<br><br><b>Restricted Fields:</b><br>metadata.annotations['container.apparmor.security.beta.kubernetes.io/*']<br><br><b>Allowed Values:</b> 'runtime/default', undefined<br></td></tr><tr><td>SELinux</td><td>Setting the SELinux type is restricted, and setting a custom SELinux user or role option is forbidden.<br><br><b>Restricted Fields:</b><br>spec.securityContext.seLinuxOptions.type<br>spec.containers[*].securityContext.seLinuxOptions.type<br>spec.initContainers[*].securityContext.seLinuxOptions.type<br><br><b>Allowed Values:</b><br>undefined/empty<br>container_t<br>container_init_t<br>container_kvm_t<br><br><b>Restricted Fields:</b><br>spec.securityContext.seLinuxOptions.user<br>spec.containers[*].securityContext.seLinuxOptions.user<br>spec.initContainers[*].securityContext.seLinuxOptions.user<br>spec.securityContext.seLinuxOptions.role<br>spec.containers[*].securityContext.seLinuxOptions.role<br>spec.initContainers[*].securityContext.seLinuxOptions.role<br><br><b>Allowed Values:</b> undefined/empty<br></td></tr><tr><td>/proc Mount Type</td><td>The default /proc masks are set up to reduce attack surface, and should be required.<br><br><b>Restricted Fields:</b><br>spec.containers[*].securityContext.procMount<br>spec.initContainers[*].securityContext.procMount<br><br><b>Allowed Values:</b> undefined/nil, 'Default'<br></td></tr><tr><td>Sysctls</td><td>Sysctls can disable security mechanisms or affect all containers on a host, and should be disallowed except for an allowed "safe" subset.
A sysctl is considered safe if it is namespaced in the container or the Pod, and it is isolated from other Pods or processes on the same Node.<br><br><b>Restricted Fields:</b><br>spec.securityContext.sysctls<br><br><b>Allowed Values:</b><br>kernel.shm_rmid_forced<br>net.ipv4.ip_local_port_range<br>net.ipv4.tcp_syncookies<br>net.ipv4.ping_group_range<br>undefined/empty<br></td></tr></tbody></table><h3 id=restricted>Restricted</h3><p>The Restricted policy is aimed at enforcing current Pod hardening best practices, at the expense of
some compatibility. It is targeted at operators and developers of security-critical applications, as
well as lower-trust users.The following listed controls should be enforced/disallowed:</p><table><caption style=display:none>Restricted policy specification</caption><tbody><tr><td><strong>Control</strong></td><td><strong>Policy</strong></td></tr><tr><td colspan=2><em>Everything from the baseline profile.</em></td></tr><tr><td>Volume Types</td><td>In addition to restricting HostPath volumes, the restricted profile limits usage of non-ephemeral volume types to those defined through PersistentVolumes.<br><br><b>Restricted Fields:</b><br>spec.volumes[*].hostPath<br>spec.volumes[*].gcePersistentDisk<br>spec.volumes[*].awsElasticBlockStore<br>spec.volumes[*].gitRepo<br>spec.volumes[*].nfs<br>spec.volumes[*].iscsi<br>spec.volumes[*].glusterfs<br>spec.volumes[*].rbd<br>spec.volumes[*].flexVolume<br>spec.volumes[*].cinder<br>spec.volumes[*].cephFS<br>spec.volumes[*].flocker<br>spec.volumes[*].fc<br>spec.volumes[*].azureFile<br>spec.volumes[*].vsphereVolume<br>spec.volumes[*].quobyte<br>spec.volumes[*].azureDisk<br>spec.volumes[*].portworxVolume<br>spec.volumes[*].scaleIO<br>spec.volumes[*].storageos<br><br><b>Allowed Values:</b> undefined/nil<br></td></tr><tr><td>Privilege Escalation</td><td>Privilege escalation (such as via set-user-ID or set-group-ID file mode) should not be allowed.<br><br><b>Restricted Fields:</b><br>spec.containers[*].securityContext.allowPrivilegeEscalation<br>spec.initContainers[*].securityContext.allowPrivilegeEscalation<br><br><b>Allowed Values:</b> false<br></td></tr><tr><td>Running as Non-root</td><td>Containers must be required to run as non-root users.<br><br><b>Restricted Fields:</b><br>spec.securityContext.runAsNonRoot<br>spec.containers[*].securityContext.runAsNonRoot<br>spec.initContainers[*].securityContext.runAsNonRoot<br><br><b>Allowed Values:</b> true<br></td></tr><tr><td>Non-root groups <em>(optional)</em></td><td>Containers should be forbidden from running with a root primary or supplementary GID.<br><br><b>Restricted Fields:</b><br>spec.securityContext.runAsGroup<br>spec.securityContext.supplementalGroups[*]<br>spec.securityContext.fsGroup<br>spec.containers[*].securityContext.runAsGroup<br>spec.initContainers[*].securityContext.runAsGroup<br><br><b>Allowed Values:</b><br>non-zero<br>undefined / nil (except for `*.runAsGroup`)<br></td></tr><tr><td>Seccomp</td><td>The RuntimeDefault seccomp profile must be required, or allow specific additional profiles.<br><br><b>Restricted Fields:</b><br>spec.securityContext.seccompProfile.type<br>spec.containers[*].securityContext.seccompProfile<br>spec.initContainers[*].securityContext.seccompProfile<br><br><b>Allowed Values:</b><br>'runtime/default'<br>undefined / nil<br></td></tr></tbody></table><h2 id=policy-instantiation>Policy Instantiation</h2><p>Decoupling policy definition from policy instantiation allows for a common understanding and
consistent language of policies across clusters, independent of the underlying enforcement
mechanism.</p><p>As mechanisms mature, they will be defined below on a per-policy basis. The methods of enforcement
of individual policies are not defined here.</p><p><a href=/docs/concepts/policy/pod-security-policy/><strong>PodSecurityPolicy</strong></a></p><ul><li><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/privileged-psp.yaml download=policy/privileged-psp.yaml>Privileged</a></li><li><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/baseline-psp.yaml download=policy/baseline-psp.yaml>Baseline</a></li><li><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/policy/restricted-psp.yaml download=policy/restricted-psp.yaml>Restricted</a></li></ul><h2 id=faq>FAQ</h2><h3 id=why-isn-t-there-a-profile-between-privileged-and-baseline>Why isn't there a profile between privileged and baseline?</h3><p>The three profiles defined here have a clear linear progression from most secure (restricted) to least
secure (privileged), and cover a broad set of workloads. Privileges required above the baseline
policy are typically very application specific, so we do not offer a standard profile in this
niche. This is not to say that the privileged profile should always be used in this case, but that
policies in this space need to be defined on a case-by-case basis.</p><p>SIG Auth may reconsider this position in the future, should a clear need for other profiles arise.</p><h3 id=what-s-the-difference-between-a-security-policy-and-a-security-context>What's the difference between a security policy and a security context?</h3><p><a href=/docs/tasks/configure-pod-container/security-context/>Security Contexts</a> configure Pods and
Containers at runtime. Security contexts are defined as part of the Pod and container specifications
in the Pod manifest, and represent parameters to the container runtime.</p><p>Security policies are control plane mechanisms to enforce specific settings in the Security Context,
as well as other parameters outside the Security Context. As of February 2020, the current native
solution for enforcing these security policies is <a href=/docs/concepts/policy/pod-security-policy/>Pod Security
Policy</a> - a mechanism for centrally enforcing security
policy on Pods across a cluster. Other alternatives for enforcing security policy are being
developed in the Kubernetes ecosystem, such as <a href=https://github.com/open-policy-agent/gatekeeper>OPA
Gatekeeper</a>.</p><h3 id=what-profiles-should-i-apply-to-my-windows-pods>What profiles should I apply to my Windows Pods?</h3><p>Windows in Kubernetes has some limitations and differentiators from standard Linux-based
workloads. Specifically, the Pod SecurityContext fields <a href=/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#v1-podsecuritycontext>have no effect on
Windows</a>. As
such, no standardized Pod Security profiles currently exists.</p><h3 id=what-about-sandboxed-pods>What about sandboxed Pods?</h3><p>There is not currently an API standard that controls whether a Pod is considered sandboxed or
not. Sandbox Pods may be identified by the use of a sandboxed runtime (such as gVisor or Kata
Containers), but there is no standard definition of what a sandboxed runtime is.</p><p>The protections necessary for sandboxed workloads can differ from others. For example, the need to
restrict privileged permissions is lessened when the workload is isolated from the underlying
kernel. This allows for workloads requiring heightened permissions to still be isolated.</p><p>Additionally, the protection of sandboxed workloads is highly dependent on the method of
sandboxing. As such, no single recommended policy is recommended for all sandboxed workloads.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d77d1ae4c06aa14f54b385191627881>3 - Controlling Access to the Kubernetes API</h1><p>This page provides an overview of controlling access to the Kubernetes API.</p><p>Users access the <a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a> using <code>kubectl</code>,
client libraries, or by making REST requests. Both human users and
<a href=/docs/tasks/configure-pod-container/configure-service-account/>Kubernetes service accounts</a> can be
authorized for API access.
When a request reaches the API, it goes through several stages, illustrated in the
following diagram:</p><p><img src=/images/docs/admin/access-control-overview.svg alt="Diagram of request handling steps for Kubernetes API request"></p><h2 id=transport-security>Transport security</h2><p>In a typical Kubernetes cluster, the API serves on port 443, protected by TLS.
The API server presents a certificate. This certificate may be signed using
a private certificate authority (CA), or based on a public key infrastructure linked
to a generally recognized CA.</p><p>If your cluster uses a private certificate authority, you need a copy of that CA
certificate configured into your <code>~/.kube/config</code> on the client, so that you can
trust the connection and be confident it was not intercepted.</p><p>Your client can present a TLS client certificate at this stage.</p><h2 id=authentication>Authentication</h2><p>Once TLS is established, the HTTP request moves to the Authentication step.
This is shown as step <strong>1</strong> in the diagram.
The cluster creation script or cluster admin configures the API server to run
one or more Authenticator modules.
Authenticators are described in more detail in
<a href=/docs/reference/access-authn-authz/authentication/>Authentication</a>.</p><p>The input to the authentication step is the entire HTTP request; however, it typically
examines the headers and/or client certificate.</p><p>Authentication modules include client certificates, password, and plain tokens,
bootstrap tokens, and JSON Web Tokens (used for service accounts).</p><p>Multiple authentication modules can be specified, in which case each one is tried in sequence,
until one of them succeeds.</p><p>If the request cannot be authenticated, it is rejected with HTTP status code 401.
Otherwise, the user is authenticated as a specific <code>username</code>, and the user name
is available to subsequent steps to use in their decisions. Some authenticators
also provide the group memberships of the user, while other authenticators
do not.</p><p>While Kubernetes uses usernames for access control decisions and in request logging,
it does not have a <code>User</code> object nor does it store usernames or other information about
users in its API.</p><h2 id=authorization>Authorization</h2><p>After the request is authenticated as coming from a specific user, the request must be authorized. This is shown as step <strong>2</strong> in the diagram.</p><p>A request must include the username of the requester, the requested action, and the object affected by the action. The request is authorized if an existing policy declares that the user has permissions to complete the requested action.</p><p>For example, if Bob has the policy below, then he can read pods only in the namespace <code>projectCaribou</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;bob&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
        <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>,
        <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
    }
}
</code></pre></div><p>If Bob makes the following request, the request is authorized because he is allowed to read objects in the <code>projectCaribou</code> namespace:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;resourceAttributes&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>,
      <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;unicorn.example.org&#34;</span>,
      <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>
    }
  }
}
</code></pre></div><p>If Bob makes a request to write (<code>create</code> or <code>update</code>) to the objects in the <code>projectCaribou</code> namespace, his authorization is denied. If Bob makes a request to read (<code>get</code>) objects in a different namespace such as <code>projectFish</code>, then his authorization is denied.</p><p>Kubernetes authorization requires that you use common REST attributes to interact with existing organization-wide or cloud-provider-wide access control systems. It is important to use REST formatting because these control systems might interact with other APIs besides the Kubernetes API.</p><p>Kubernetes supports multiple authorization modules, such as ABAC mode, RBAC Mode, and Webhook mode. When an administrator creates a cluster, they configure the authorization modules that should be used in the API server. If more than one authorization modules are configured, Kubernetes checks each module, and if any module authorizes the request, then the request can proceed. If all of the modules deny the request, then the request is denied (HTTP status code 403).</p><p>To learn more about Kubernetes authorization, including details about creating policies using the supported authorization modules, see <a href=/docs/reference/access-authn-authz/authorization/>Authorization</a>.</p><h2 id=admission-control>Admission control</h2><p>Admission Control modules are software modules that can modify or reject requests.
In addition to the attributes available to Authorization modules, Admission
Control modules can access the contents of the object that is being created or modified.</p><p>Admission controllers act on requests that create, modify, delete, or connect to (proxy) an object.
Admission controllers do not act on requests that merely read objects.
When multiple admission controllers are configured, they are called in order.</p><p>This is shown as step <strong>3</strong> in the diagram.</p><p>Unlike Authentication and Authorization modules, if any admission controller module
rejects, then the request is immediately rejected.</p><p>In addition to rejecting objects, admission controllers can also set complex defaults for
fields.</p><p>The available Admission Control modules are described in <a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Controllers</a>.</p><p>Once a request passes all admission controllers, it is validated using the validation routines
for the corresponding API object, and then written to the object store (shown as step <strong>4</strong>).</p><h2 id=api-server-ports-and-ips>API server ports and IPs</h2><p>The previous discussion applies to requests sent to the secure port of the API server
(the typical case). The API server can actually serve on 2 ports:</p><p>By default, the Kubernetes API server serves HTTP on 2 ports:</p><ol><li><p><code>localhost</code> port:</p><ul><li>is intended for testing and bootstrap, and for other components of the master node
(scheduler, controller-manager) to talk to the API</li><li>no TLS</li><li>default is port 8080, change with <code>--insecure-port</code> flag.</li><li>default IP is localhost, change with <code>--insecure-bind-address</code> flag.</li><li>request <strong>bypasses</strong> authentication and authorization modules.</li><li>request handled by admission control module(s).</li><li>protected by need to have host access</li></ul></li><li><p>“Secure port”:</p><ul><li>use whenever possible</li><li>uses TLS. Set cert with <code>--tls-cert-file</code> and key with <code>--tls-private-key-file</code> flag.</li><li>default is port 6443, change with <code>--secure-port</code> flag.</li><li>default IP is first non-localhost network interface, change with <code>--bind-address</code> flag.</li><li>request handled by authentication and authorization modules.</li><li>request handled by admission control module(s).</li><li>authentication and authorization modules run.</li></ul></li></ol><h2 id=what-s-next>What's next</h2><p>Read more documentation on authentication, authorization and API access control:</p><ul><li><a href=/docs/reference/access-authn-authz/authentication/>Authenticating</a><ul><li><a href=/docs/reference/access-authn-authz/bootstrap-tokens/>Authenticating with Bootstrap Tokens</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Controllers</a><ul><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>Dynamic Admission Control</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/authorization/>Authorization</a><ul><li><a href=/docs/reference/access-authn-authz/rbac/>Role Based Access Control</a></li><li><a href=/docs/reference/access-authn-authz/abac/>Attribute Based Access Control</a></li><li><a href=/docs/reference/access-authn-authz/node/>Node Authorization</a></li><li><a href=/docs/reference/access-authn-authz/webhook/>Webhook Authorization</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/>Certificate Signing Requests</a><ul><li>including <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection>CSR approval</a>
and <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#signing>certificate signing</a></li></ul></li><li>Service accounts<ul><li><a href=/docs/tasks/configure-pod-container/configure-service-account/>Developer guide</a></li><li><a href=/docs/reference/access-authn-authz/service-accounts-admin/>Administration</a></li></ul></li></ul><p>You can learn about:</p><ul><li>how Pods can use
<a href=/docs/concepts/configuration/secret/#service-accounts-automatically-create-and-attach-secrets-with-api-credentials>Secrets</a>
to obtain API credentials.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script></body></html>