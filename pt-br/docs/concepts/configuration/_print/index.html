<!doctype html><html lang=pt-br class=no-js><head><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/configuration/><link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/configuration/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/configuration/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/configuration/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/configuration/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/configuration/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/configuration/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/configuration/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/configuration/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.82.0"><link rel=canonical type=text/html href=https://kubernetes.io/pt-br/docs/concepts/configuration/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Configuração | Kubernetes</title><meta property="og:title" content="Configuração"><meta property="og:description" content="Orquestração de contêineres em nível de produção"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/configuration/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Configuração"><meta itemprop=description content="Orquestração de contêineres em nível de produção"><meta name=twitter:card content="summary"><meta name=twitter:title content="Configuração"><meta name=twitter:description content="Orquestração de contêineres em nível de produção"><link rel=preload href=/scss/main.min.a4bbbf4cec44bb587f51c9896c6b721ca3ded0a7e145b8a5941d804afbcc0c8d.css as=style><link href=/scss/main.min.a4bbbf4cec44bb587f51c9896c6b721ca3ded0a7e145b8a5941d804afbcc0c8d.css rel=stylesheet integrity><script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/configuration/"><meta property="og:title" content="Configuração"><meta name=twitter:title content="Configuração"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/script.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/pt-br/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/pt-br/docs/>Documentação</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/blog/>Kubernetes Blog</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/partners/>Parceiros</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/community/>Comunidade</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/case-studies/>Casos de estudo</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versões</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/pt-br/docs/concepts/configuration/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Português</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/configuration/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/configuration/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/configuration/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/configuration/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/configuration/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/configuration/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/configuration/>Español</a>
<a class=dropdown-item href=/id/docs/concepts/configuration/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/configuration/>Українська</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Essa é a versão completa de impressão dessa seção
<a href=# onclick="return print(),!1">Clique aqui para imprimir</a>.</p><p><a href=/pt-br/docs/concepts/configuration/>Retornar à visualização normal</a>.</p></div><h1 class=title>Configuração</h1><ul><li>1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>Melhores Práticas de Configuração</a></li><li>2: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Organizando o acesso ao cluster usando arquivos kubeconfig</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>1 - Melhores Práticas de Configuração</h1><p>Esse documento destaca e consolida as melhores práticas de configuração apresentadas em todo o guia de usuário,
na documentação de introdução e nos exemplos.</p><p>Este é um documento vivo. Se você pensar em algo que não está nesta lista, mas pode ser útil para outras pessoas,
não hesite em criar uma <em>issue</em> ou submeter um PR.</p><h2 id=dicas-gerais-de-configuração>Dicas Gerais de Configuração</h2><ul><li><p>Ao definir configurações, especifique a versão mais recente estável da API.</p></li><li><p>Os arquivos de configuração devem ser armazenados em um sistema de controle antes de serem enviados ao cluster.
Isso permite que você reverta rapidamente uma alteração de configuração, caso necessário. Isso também auxilia na recriação e restauração do cluster.</p></li><li><p>Escreva seus arquivos de configuração usando YAML ao invés de JSON. Embora esses formatos possam ser usados alternadamente em quase todos os cenários, YAML tende a ser mais amigável.</p></li><li><p>Agrupe objetos relacionados em um único arquivo sempre que fizer sentido. Geralmente, um arquivo é mais fácil de
gerenciar do que vários. Veja o <a href=https://github.com/kubernetes/examples/tree/v1.21.14/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> como exemplo dessa sintaxe.</p></li><li><p>Observe também que vários comandos <code>kubectl</code> podem ser chamados em um diretório. Por exemplo, você pode chamar
<code>kubectl apply</code> em um diretório de arquivos de configuração.</p></li><li><p>Não especifique valores padrões desnecessariamente: configurações simples e mínimas diminuem a possibilidade de erros.</p></li><li><p>Coloque descrições de objetos nas anotações para permitir uma melhor análise.</p></li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"Naked" Pods comparados a ReplicaSets, Deployments, e Jobs</h2><ul><li><p>Se você puder evitar, não use "naked" Pods (ou seja, se você puder evitar, pods não vinculados a um <a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> ou <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>).
Os "naked" pods não serão reconfigurados em caso de falha de um nó.</p><p>Criar um Deployment, que cria um ReplicaSet para garantir que o número desejado de Pods esteja disponível e especifica uma estratégia para substituir os Pods (como <a href=/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>RollingUpdate</a>), é quase sempre preferível do que criar Pods diretamente, exceto para alguns cenários explícitos de restartPolicy:Never. Um Job também pode ser apropriado.</p></li></ul><h2 id=services>Services</h2><ul><li><p>Crie o <a href=/docs/concepts/services-networking/service/>Service</a> antes de suas cargas de trabalho de backend correspondentes (Deployments ou ReplicaSets) e antes de quaisquer cargas de trabalho que precisem acessá-lo. Quando o
Kubernetes inicia um contêiner, ele fornece variáveis de ambiente apontando para todos os Services que estavam em execução quando o contêiner foi iniciado. Por exemplo, se um Service chamado <code>foo</code> existe, todos os contêineres vão
receber as seguintes variáveis em seu ambiente inicial:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;o host em que o Service está executando&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;a porta em que o Service está executando&gt;
</code></pre></div></li></ul><p><em>Isso implica em um requisito de pedido</em> - qualquer <code>Service</code> que um <code>Pod</code> quer acessar precisa ser criado antes do <code>Pod</code> em si, ou então as variáveis de ambiente não serão populadas. O DNS não possui essa restrição.</p><ul><li><p>Um <a href=/docs/concepts/cluster-administration/addons/>cluster add-on</a> opcional (embora fortemente recomendado) é um servidor DNS. O
servidor DNS monitora a API do Kubernetes buscando novos <code>Services</code> e cria um conjunto de DNS para cada um. Se o DNS foi habilitado em todo o cluster, então todos os <code>Pods</code> devem ser capazes de fazer a resolução de <code>Services</code> automaticamente.</p></li><li><p>Não especifique um <code>hostPort</code> para um Pod a menos que isso seja absolutamente necessário. Quando você vincula um Pod a um <code>hostPort</code>, isso limita o número de lugares em que o Pod pode ser agendado, porque cada
combinação de &lt;<code>hostIP</code>, <code>hostPort</code>, <code>protocol</code>> deve ser única. Se você não especificar o <code>hostIP</code> e <code>protocol</code> explicitamente, o Kubernetes vai usar <code>0.0.0.0</code> como o <code>hostIP</code> padrão e <code>TCP</code> como <code>protocol</code> padrão.</p><p>Se você precisa de acesso a porta apenas para fins de depuração, pode usar o <a href=/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a> ou o <a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>.</p><p>Se você precisa expor explicitamente a porta de um Pod no nó, considere usar um Service do tipo <a href=/docs/concepts/services-networking/service/#nodeport>NodePort</a> antes de recorrer a <code>hostPort</code>.</p></li><li><p>Evite usar <code>hostNetwork</code> pelos mesmos motivos do <code>hostPort</code>.</p></li><li><p>Use <a href=/docs/concepts/services-networking/service/#headless-services>headless Services</a> (que tem um <code>ClusterIP</code> ou <code>None</code>) para descoberta de serviço quando você não precisar de um balanceador de carga <code>kube-proxy</code>.</p></li></ul><h2 id=usando-labels>Usando Labels</h2><ul><li>Defina e use <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> que identifiquem <em>atributos semânticos</em> da sua aplicação ou Deployment, como <code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>. Você pode usar essas labels para selecionar os Pods apropriados para outros recursos; por exemplo, um Service que seleciona todos os Pods <code>tier: frontend</code>, ou todos
os componentes de <code>app: myapp</code>. Veja o app <a href=https://github.com/kubernetes/examples/tree/v1.21.14/guestbook/>guestbook</a> para exemplos dessa abordagem.</li></ul><p>Um Service pode ser feito para abranger vários Deployments, omitindo labels específicas de lançamento de seu seletor. Quando você
precisar atualizar um serviço em execução sem <em>downtime</em>, use um <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>.</p><p>Um estado desejado de um objeto é descrito por um Deployment, e se as alterações nesse <em>spec</em> forem <em>aplicadas</em> o controlador
do Deployment altera o estado real para o estado desejado em uma taxa controlada.</p><ul><li><p>Use as <a href=/docs/concepts/overview/working-with-objects/common-labels/>labels comuns do Kubernetes</a> para casos de uso comuns.
Essas labels padronizadas enriquecem os metadados de uma forma que permite que ferramentas, incluindo <code>kubectl</code> e a <a href=/docs/tasks/access-application-cluster/web-ui-dashboard>dashboard</a>, funcionem de uma forma interoperável.</p></li><li><p>Você pode manipular labels para depuração. Como os controladores do Kubernetes (como ReplicaSet) e Services se relacionam com os Pods usando seletor de labels, remover as labels relevantes de um Pod impedirá que ele seja considerado por um controlador ou que
seja atendido pelo tráfego de um Service. Se você remover as labels de um Pod existente, seu controlador criará um novo Pod para
substituí-lo. Essa é uma maneira útil de depurar um Pod anteriormente "ativo" em um ambiente de "quarentena". Para remover ou
alterar labels interativamente, use <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>.</p></li></ul><h2 id=imagens-de-contêiner>Imagens de Contêiner</h2><p>A <a href=/docs/concepts/containers/images/#updating-images>imagePullPolicy</a> e tag da imagem afetam quando o <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> tenta puxar a imagem especificada.</p><ul><li><p><code>imagePullPolicy: IfNotPresent</code>: a imagem é puxada apenas se ainda não estiver presente localmente.</p></li><li><p><code>imagePullPolicy: Always</code>: sempre que o kubelet inicia um contêiner, ele consulta o <em>registry</em> da imagem do contêiner para verificar o resumo de assinatura da imagem. Se o kubelet tiver uma imagem do contêiner com o mesmo resumo de assinatura
armazenado em cache localmente, o kubelet usará a imagem em cache, caso contrário, o kubelet baixa(<em>pulls</em>) a imagem com o resumo de assinatura resolvido, e usa essa imagem para iniciar o contêiner.</p></li><li><p><code>imagePullPolicy</code> é omitido se a tag da imagem é <code>:latest</code> ou se <code>imagePullPolicy</code> é omitido é automaticamente definido como <code>Always</code>. Observe que <em>não</em> será utilizado para <code>ifNotPresent</code>se o valor da tag mudar.</p></li><li><p><code>imagePullPolicy</code> é omitido se uma tag da imagem existe mas não <code>:latest</code>: <code>imagePullPolicy</code> é automaticamente definido como <code>ifNotPresent</code>. Observe que isto <em>não</em> será atualizado para <code>Always</code> se a tag for removida ou alterada para <code>:latest</code>.</p></li><li><p><code>imagePullPolicy: Never</code>: presume-se que a imagem exista localmente. Não é feita nenhuma tentativa de puxar a imagem.</p></li></ul><blockquote class="note callout"><div><strong>Nota:</strong> Para garantir que seu contêiner sempre use a mesma versão de uma imagem, você pode especificar seu <a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>resumo de assinatura</a>;
substitua <code>&lt;nome-da-imagem>:&lt;tag></code> por <code>&lt;nome-da-imagem>@&lt;hash></code> (por exemplo, <code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>). Esse resumo de assinatura identifica exclusivamente uma versão
específica de uma imagem, então isso nunca vai ser atualizado pelo Kubernetes a menos que você mude o valor do resumo de assinatura da imagem.</div></blockquote><blockquote class="note callout"><div><strong>Nota:</strong> Você deve evitar o uso da tag <code>:latest</code> em produção, pois é mais difícil rastrear qual versão da imagem está sendo executada e mais difícil reverter adequadamente.</div></blockquote><blockquote class="note callout"><div><strong>Nota:</strong> A semântica de cache do provedor de imagem subjacente torna até mesmo <code>imagePullPolicy: Always</code> eficiente, contanto que o registro esteja acessível de forma confiável. Com o Docker, por exemplo, se a imagem já existe, a tentativa de baixar(pull) é rápida porque todas as camadas da imagem são armazenadas em cache e nenhum download de imagem é necessário.</div></blockquote><h2 id=usando-kubectl>Usando kubectl</h2><ul><li><p>Use <code>kubectl apply -f &lt;directory></code>. Isso procura por configurações do Kubernetes em todos os arquivos <code>.yaml</code>, <code>.yml</code> em <code>&lt;directory></code> e passa isso para <code>apply</code>.</p></li><li><p>Use <em>labels selectors</em> para operações <code>get</code> e <code>delete</code> em vez de nomes de objetos específicos. Consulte as seções sobre <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>label selectors</a>
e <a href=/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>usando Labels efetivamente</a>.</p></li><li><p>Use <code>kubectl create deployment</code> e <code>kubectl expose</code> para criar rapidamente Deployments e Services de um único contêiner. Consulte <a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Use um Service para acessar uma aplicação em um cluster</a> para obter um exemplo.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>2 - Organizando o acesso ao cluster usando arquivos kubeconfig</h1><p>Utilize arquivos kubeconfig para organizar informações sobre clusters, usuários, namespaces e mecanismos de autenticação. A ferramenta de linha de comando <code>kubectl</code> faz uso dos arquivos kubeconfig para encontrar as informações necessárias para escolher e se comunicar com o serviço de API de um cluster.</p><blockquote class="note callout"><div><strong>Nota:</strong> Um arquivo que é utilizado para configurar o acesso aos clusters é chamado de <em>kubeconfig</em>. Esta á uma forma genérica de referenciamento para um arquivo de configuração desta natureza. Isso não significa que existe um arquivo com o nome <code>kubeconfig</code>.</div></blockquote><p>Por padrão, o <code>kubectl</code> procura por um arquivo de nome <code>config</code> no diretório <code>$HOME/.kube</code></p><p>Você pode especificar outros arquivos kubeconfig através da variável de ambiente <code>KUBECONFIG</code> ou adicionando a opção <a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>.</p><p>Para maiores detalhes na criação e especificação de um kubeconfig, veja o passo a passo em <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters>Configurar Acesso para Múltiplos Clusters</a>.</p><h2 id=suportando-múltiplos-clusters-usuários-e-mecanismos-de-autenticação>Suportando múltiplos clusters, usuários e mecanismos de autenticação</h2><p>Imagine que você possua inúmeros clusters, e seus usuários e componentes se autenticam de várias formas. Por exemplo:</p><ul><li>Um kubelet ativo pode se autenticar utilizando certificados</li><li>Um usuário pode se autenticar através de tokens</li><li>Administradores podem possuir conjuntos de certificados os quais provém acesso aos usuários de forma individual.</li></ul><p>Através de arquivos kubeconfig, você pode organizar os seus clusters, usuários, e namespaces. Você também pode definir contextos para uma fácil troca entre clusters e namespaces.</p><h2 id=contexto>Contexto</h2><p>Um elemento de <em>contexto</em> em um kubeconfig é utilizado para agrupar parâmetros de acesso em um nome conveniente. Cada contexto possui três parâmetros: cluster, namespace, e usuário.</p><p>Por padrão, a ferramenta de linha de comando <code>kubectl</code> utiliza os parâmetros do <em>contexto atual</em> para se comunicar com o cluster.</p><p>Para escolher o contexto atual:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config use-context
</code></pre></div><h2 id=a-variável-de-ambiente-kubeconfig>A variável de ambiente KUBECONFIG</h2><p>A variável de ambiente <code>KUBECONFIG</code> possui uma lista dos arquivos kubeconfig. Para Linux e Mac, esta lista é delimitada por vírgula. No Windows, a lista é delimitada por ponto e vírgula. A variável de ambiente <code>KUBECONFIG</code> não é um requisito obrigatório - caso ela não exista o <code>kubectl</code> utilizará o arquivo kubeconfig padrão localizado no caminho <code>$HOME/.kube/config</code>.</p><p>Se a variável de ambiente <code>KUBECONFIG</code> existir, o <code>kubectl</code> utilizará uma configuração que é o resultado da combinação dos arquivos listados na variável de ambiente <code>KUBECONFIG</code>.</p><h2 id=combinando-arquivos-kubeconfig>Combinando arquivos kubeconfig</h2><p>Para inspecionar a sua configuração atual, execute o seguinte comando:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><p>Como descrito anteriormente, a saída poderá ser resultado de um único arquivo kubeconfig, ou poderá ser o resultado da junção de vários arquivos kubeconfig.</p><p>Aqui estão as regras que o <code>kubectl</code> utiliza quando realiza a combinação de arquivos kubeconfig:</p><ol><li><p>Se o argumento <code>--kubeconfig</code> está definido, apenas o arquivo especificado será utilizado. Apenas uma instância desta flag é permitida.</p><p>Caso contrário, se a variável de ambiente <code>KUBECONFIG</code> estiver definida, esta deverá ser utilizada como uma lista de arquivos a serem combinados, seguindo o fluxo a seguir:</p><ul><li>Ignorar arquivos vazios.</li><li>Produzir erros para aquivos cujo conteúdo não for possível desserializar.</li><li>O primeiro arquivo que definir um valor ou mapear uma chave determinada, será o escolhido.</li><li>Nunca modificar um valor ou mapear uma chave.
Exemplo: Preservar o contexto do primeiro arquivo que definir <code>current-context</code>.
Exemplo: Se dois arquivos especificarem um <code>red-user</code>, use apenas os valores do primeiro <code>red-user</code>. Mesmo se um segundo arquivo possuir entradas não conflitantes sobre a mesma entrada <code>red-user</code>, estas deverão ser descartadas.</li></ul><p>Para um exemplo de definição da variável de ambiente <code>KUBECONFIG</code> veja <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>Definido a variável de ambiente KUBECONFIG</a>.</p><p>Caso contrário, utilize o arquivo kubeconfig padrão encontrado no diretório <code>$HOME/.kube/config</code>, sem qualquer tipo de combinação.</p></li><li><p>Determine o contexto a ser utilizado baseado no primeiro padrão encontrado, nesta ordem:</p><ol><li>Usar o conteúdo da flag <code>--context</code> caso ela existir.</li><li>Usar o <code>current-context</code> a partir da combinação dos arquivos kubeconfig.</li></ol><p>Um contexto vazio é permitido neste momento.</p></li><li><p>Determinar o cluster e o usuário. Neste ponto, poderá ou não existir um contexto.
Determinar o cluster e o usuário no primeiro padrão encontrado de acordo com a ordem à seguir. Este procedimento deverá executado duas vezes: uma para definir o usuário a outra para definir o cluster.</p><ol><li>Utilizar a flag caso ela existir: <code>--user</code> ou <code>--cluster</code>.</li><li>Se o contexto não estiver vazio, utilizar o cluster ou usuário deste contexto.</li></ol><p>O usuário e o cluster poderão estar vazios neste ponto.</p></li><li><p>Determinar as informações do cluster atual a serem utilizadas. Neste ponto, poderá ou não existir informações de um cluster.</p><p>Construir cada peça de informação do cluster baseado nas opções à seguir; a primeira ocorrência encontrada será a opção vencedora:</p><ol><li>Usar as flags de linha de comando caso existirem: <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>.</li><li>Se algum atributo do cluster existir a partir da combinação de kubeconfigs, estes deverão ser utilizados.</li><li>Se não existir informação de localização do servidor falhar.</li></ol></li><li><p>Determinar a informação atual de usuário a ser utilizada. Construir a informação de usuário utilizando as mesmas regras utilizadas para o caso de informações de cluster, exceto para a regra de técnica de autenticação que deverá ser única por usuário:</p><ol><li>Usar as flags, caso existirem: <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>.</li><li>Usar os campos <code>user</code> resultado da combinação de arquivos kubeconfig.</li><li>Se existirem duas técnicas conflitantes, falhar.</li></ol></li><li><p>Para qualquer informação que ainda estiver ausente, utilizar os valores padrão e potencialmente solicitar informações de autenticação a partir do prompt de comando.</p></li></ol><h2 id=referências-de-arquivos>Referências de arquivos</h2><p>Arquivos e caminhos referenciados em um arquivo kubeconfig são relativos à localização do arquivo kubeconfig.</p><p>Referências de arquivos na linha de comando são relativas ao diretório de trabalho vigente.</p><p>No arquivo <code>$HOME/.kube/config</code>, caminhos relativos são armazenados de forma relativa, e caminhos absolutos são armazenados de forma absoluta.</p><h2 id=qual-é-o-próximo>Qual é o próximo</h2><ul><li><a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Configurar Accesso para Multiplos Clusters</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/pt-br/docs/home/>Home</a>
<a class=text-white href=/pt-br/blog/>Blog</a>
<a class=text-white href=/pt-br/partners/>Parceiros</a>
<a class=text-white href=/pt-br/community/>Comunidade</a>
<a class=text-white href=/pt-br/case-studies/>Casos de estudo</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Os autores do Kubernetes | Documentação Distribuída sob <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 A Fundação Linux &reg;. Todos os direitos reservados. A Linux Foundation tem marcas registradas e usa marcas registradas. Para uma lista de marcas registradas da The Linux Foundation, por favor, veja nossa <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Página de uso de marca registrada</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script></body></html>