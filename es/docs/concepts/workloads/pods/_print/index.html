<!doctype html><html lang=es class=no-js><head><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/pods/><link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/workloads/pods/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/workloads/pods/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/workloads/pods/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/workloads/pods/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/workloads/pods/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/workloads/pods/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.82.0"><link rel=canonical type=text/html href=https://kubernetes.io/es/docs/concepts/workloads/pods/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Pods | Kubernetes</title><meta property="og:title" content="Pods"><meta property="og:description" content="Orquestación de contenedores para producción"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/es/docs/concepts/workloads/pods/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Pods"><meta itemprop=description content="Orquestación de contenedores para producción"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pods"><meta name=twitter:description content="Orquestación de contenedores para producción"><link rel=preload href=/scss/main.min.a4bbbf4cec44bb587f51c9896c6b721ca3ded0a7e145b8a5941d804afbcc0c8d.css as=style><link href=/scss/main.min.a4bbbf4cec44bb587f51c9896c6b721ca3ded0a7e145b8a5941d804afbcc0c8d.css rel=stylesheet integrity><script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/es/docs/concepts/workloads/pods/"><meta property="og:title" content="Pods"><meta name=twitter:title content="Pods"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/script.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/es/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/es/docs/>Documentación</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/es/blog/>Kubernetes Blog</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/es/partners/>Partners</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/es/community/>Comunidad</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/es/case-studies/>Casos de éxito</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/es/docs/concepts/workloads/pods/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/es/docs/concepts/workloads/pods/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/es/docs/concepts/workloads/pods/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/es/docs/concepts/workloads/pods/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/es/docs/concepts/workloads/pods/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Español</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/workloads/pods/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/workloads/pods/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/workloads/pods/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/workloads/pods/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/workloads/pods/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/workloads/pods/>Deutsch</a>
<a class=dropdown-item href=/id/docs/concepts/workloads/pods/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/es/docs/concepts/workloads/pods/>Return to the regular view of this page</a>.</p></div><h1 class=title>Pods</h1><ul><li>1: <a href=#pg-99cce294fe789317ee684a6e1f07f20f>Pods</a></li><li>2: <a href=#pg-4e9b9cbc9776b12e7335c53da377c9c8>Pod Preset</a></li><li>3: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>Containers Efímeros</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-99cce294fe789317ee684a6e1f07f20f>1 - Pods</h1><p>Los <em>Pods</em> son las unidades de computación desplegables más pequeñas que se pueden crear y gestionar en Kubernetes.</p><h2 id=qué-és-un-pod>¿Qué és un Pod?</h2><p>Un <em>Pod</em> (como en una vaina de ballenas o vaina de guisantes) es un grupo de uno o más contenedores (como contenedores Docker), con almacenamiento/red compartidos, y unas especificaciones de cómo ejecutar los contenedores. Los contenidos de un Pod son siempre coubicados, coprogramados y ejecutados en un contexto compartido. Un Pod modela un "host lógico" específico de la aplicación: contiene uno o más contenedores de aplicaciones relativamente entrelazados. Antes de la llegada de los contenedores, ejecutarse en la misma máquina física o virtual significaba ser ejecutado en el mismo host lógico.</p><p>Mientras que Kubernetes soporta más <a class=glossary-tooltip title="El Container Runtime, entorno de ejecución de un contenedor, es el software responsable de ejecutar contenedores." data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label="runtimes de contenedores">runtimes de contenedores</a> a parte de Docker, este último es el más conocido y ayuda a describir Pods en términos de Docker.</p><p>El contexto compartido de un Pod es un conjunto de namespaces de Linux, cgroups y, potencialmente, otras facetas de aislamiento, las mismas cosas que aíslan un contenedor Docker. Dentro del contexto de un Pod, las aplicaciones individuales pueden tener más subaislamientos aplicados.</p><p>Los contenedores dentro de un Pod comparten dirección IP y puerto, y pueden encontrarse a través de <code>localhost</code>. También pueden comunicarse entre sí mediante comunicaciones estándar entre procesos, como semáforos de SystemV o la memoria compartida POSIX. Los contenedores en diferentes Pods tienen direcciones IP distintas y no pueden comunicarse por IPC sin <a href=/docs/concepts/policy/pod-security-policy/>configuración especial</a>.
Estos contenedores normalmente se comunican entre sí a través de las direcciones IP del Pod.</p><p>Las aplicaciones dentro de un Pod también tienen acceso a <a class=glossary-tooltip title="Un directorio que contiene datos y que es accesible desde los contenedores corriendo en un pod." data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volúmenes>volúmenes</a> compartidos, que se definen como parte de un Pod y están disponibles para ser montados en el sistema de archivos de cada aplicación.</p><p>En términos de <a href=https://www.docker.com/>Docker</a>, un Pod se modela como un grupo de contenedores de Docker con namespaces y volúmenes de sistemas de archivos compartidos.</p><p>Al igual que los contenedores de aplicaciones individuales, los Pods se consideran entidades relativamente efímeras (en lugar de duraderas). Como se explica en <a href=/docs/concepts/workloads/pods/pod-lifecycle/>ciclo de vida del pod</a>, los Pods se crean, se les asigna un identificador único (UID) y se planifican en nodos donde permanecen hasta su finalización (según la política de reinicio) o supresión. Si un <a class=glossary-tooltip title="Un Node, nodo en castellano, es una de las máquinas del clúster de Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nodo>nodo</a> muere, los Pods programados para ese nodo se programan para su eliminación después de un período de tiempo de espera. Un Pod dado (definido por su UID) no se "replanifica" a un nuevo nodo; en su lugar, puede reemplazarse por un Pod idéntico, con incluso el mismo nombre si lo desea, pero con un nuevo UID (consulte <a href=/es/docs/concepts/workloads/controllers/replicationcontroller/>controlador de replicación</a> para obtener más detalles).</p><p>Cuando se dice que algo tiene la misma vida útil que un Pod, como un volumen, significa que existe mientras exista ese Pod (con ese UID). Si ese Pod se elimina por cualquier motivo, incluso si se crea un reemplazo idéntico, el recurso relacionado (por ejemplo, el volumen) también se destruye y se crea de nuevo.<figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>diagrama de Pod</h4></figcaption></figure></p><p><em>Un Pod de múltiples contenedores que contiene un extractor de archivos y un servidor web que utiliza un volumen persistente para el almacenamiento compartido entre los contenedores.</em></p><h2 id=motivación-para-los-pods>Motivación para los Pods</h2><h3 id=gestión>Gestión</h3><p>Los Pods son un modelo del patrón de múltiples procesos de cooperación que forman una unidad de servicio cohesiva. Simplifican la implementación y la administración de las aplicaciones proporcionando una abstracción de mayor nivel que el conjunto de las aplicaciones que lo constituyen. Los Pods sirven como unidad de despliegue, escalado horizontal y replicación. La colocación (coprogramación), el destino compartido (por ejemplo, la finalización), la replicación coordinada, el uso compartido de recursos y la gestión de dependencias se controlan automáticamente para los contenedores en un Pod.</p><h3 id=recursos-compartidos-y-comunicación>Recursos compartidos y comunicación</h3><p>Los Pods permiten el intercambio de datos y la comunicación entre los contenedores que lo constituyen.</p><p>Todas las aplicaciones en un Pod utilizan el mismo namespace de red (la misma IP y puerto) y, por lo tanto, pueden "encontrarse" entre sí y comunicarse utilizando <code>localhost</code>.
Debido a esto, las aplicaciones en un Pod deben coordinar su uso de puertos. Cada Pod tiene una dirección IP en un espacio de red compartido que tiene comunicación completa con otros servidores físicos y Pods a través de la red.</p><p>Los contenedores dentro del Pod ven que el hostname del sistema es el mismo que el <code>nombre</code> configurado para el Pod. Hay más información sobre esto en la sección <a href=/docs/concepts/cluster-administration/networking/>networking</a>.</p><p>Además de definir los contenedores de aplicaciones que se ejecutan en el Pod, el Pod especifica un conjunto de volúmenes de almacenamiento compartido. Los volúmenes permiten que los datos sobrevivan a reinicios de contenedores y se compartan entre las aplicaciones dentro del Pod.</p><h2 id=usos-de-pods>Usos de Pods</h2><p>Los Pods pueden ser usados para alojar pilas de aplicaciones integradas (por ejemplo, LAMP), pero su objetivo principal es apoyar los programas de ayuda coubicados y coadministrados, como:</p><ul><li>sistemas de gestión de contenido, loaders de datos y archivos, gestores de caché locales, etc.</li><li>copia de seguridad de registro y punto de control, compresión, rotación, captura de imágenes, etc.</li><li>observadores de cambio de datos, adaptadores de registro y monitoreo, publicadores de eventos, etc.</li><li>proxies, bridges y adaptadores.</li><li>controladores, configuradores y actualizadores.</li></ul><p>Los Pods individuales no están diseñados para ejecutar varias instancias de la misma aplicación, en general.</p><p>Para una explicación más detallada, ver <a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>El sistema distribuido ToolKit: Patrones para Contenedores multiaplicación</a>.</p><h2 id=alternativas>Alternativas</h2><p><em>¿Por qué simplemente no ejecutar múltiples programas en un solo contenedor de Docker?</em></p><ol><li>Transparencia. Hacer visibles los contenedores dentro del Pod
a la infraestructura permite que esta brinde servicios, como gestión de procesos
y monitoreo de recursos, a los contenedores, facilitando una
serie de comodidades a los usuarios.</li><li>Desacople de dependencias de software. Los contenedores individuales pueden ser
versionados, reconstruidos y redistribuidos independientemente. Kubernetes podría incluso apoyar
actualizaciones en vivo de contenedores individuales en un futuro.</li><li>Facilidad de uso. Los usuarios no necesitan ejecutar sus propios administradores de procesos,
para propagación de señales, códigos de salida, etc.</li><li>Eficiencia. Debido a que la infraestructura asume más responsabilidad,
los contenedores pueden ser más livianos.</li></ol><p><em>¿Por qué no admitir la planificación conjunta de contenedores por afinidad?</em></p><p>Ese enfoque proporcionaría la ubicación conjunta, pero no la mayor parte de
beneficios de los Pods, como compartir recursos, IPC, compartir el destino garantizado y
gestión simplificada.</p><h2 id=durabilidad-de-pods-o-su-ausencia>Durabilidad de pods (o su ausencia)</h2><p>Los Pods no están destinados a ser tratados como entidades duraderas. No sobrevivirán a errores de planificación, caídas de nodo u otros desalojos, ya sea por falta de recursos o en el caso de mantenimiento de nodos.</p><p>En general, los usuarios no deberían necesitar crear Pods directamente, deberían
usar siempre controladores incluso para Pods individuales, como por ejemplo, los
<a href=/es/docs/concepts/workloads/controllers/deployment/>Deployments</a>.
Los controladores proporcionan autorecuperación con un alcance de clúster, así como replicación
y gestión de despliegue.
Otros controladores como los <a href=/es/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>
pueden tambien proporcionar soporte para Pods que necesiten persistir el estado.</p><p>El uso de API colectivas como la principal primitiva de cara al usuario es relativamente común entre los sistemas de planificación de clúster, incluyendo <a href=https://research.google.com/pubs/pub43438.html>Borg</a>, <a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a>, <a href=http://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a>, y <a href=http://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997>Tupperware</a>.</p><p>El Pod se expone como primitiva para facilitar:</p><ul><li>planificación y capacidad de conexión del controlador</li><li>soporte para operaciones a nivel de Pod sin la necesidad de "proxy" a través de las API del controlador</li><li>desacople de la vida útil del Pod de la vida útil del controlador, como para el arranque</li><li>desacople de controladores y servicios, el endpoint del controlador solo mira Pods</li><li>composición limpia de funcionalidad a nivel de Kubelet con funcionalidad a nivel de clúster, Kubelet es efectivamente el "controlador de Pod"</li><li>aplicaciones en alta disponibilidad, que esperan que los Pods sean reemplazados antes de su finalización y ciertamente antes de su eliminación, como en el caso de desalojos planificados o descarga previa de imágenes.</li></ul><h2 id=finalización-de-pods>Finalización de Pods</h2><p>Debido a que los Pods representan procesos en ejecución en los nodos del clúster, es importante permitir que esos procesos finalicen de forma correcta cuando ya no se necesiten (en lugar de ser detenidos bruscamente con una señal de KILL). Los usuarios deben poder solicitar la eliminación y saber cuándo finalizan los procesos, pero también deben poder asegurarse de que las eliminaciones finalmente se completen. Cuando un usuario solicita la eliminación de un Pod, el sistema registra el período de gracia previsto antes de que el Pod pueda ser eliminado de forma forzada, y se envía una señal TERM al proceso principal en cada contenedor. Una vez que el período de gracia ha expirado, la señal KILL se envía a esos procesos y el Pod se elimina del servidor API. Si se reinicia Kubelet o el administrador de contenedores mientras se espera que finalicen los procesos, la terminación se volverá a intentar con el período de gracia completo.</p><p>Un ejemplo del ciclo de terminación de un Pod:</p><ol><li>El usuario envía un comando para eliminar Pod, con un período de gracia predeterminado (30s)</li><li>El Pod en el servidor API se actualiza con el tiempo a partir del cual el Pod se considera "muerto" junto con el período de gracia.</li><li>El Pod aparece como "Terminando" cuando aparece en los comandos del cliente</li><li>(simultáneo con 3) Cuando el Kubelet ve que un Pod se ha marcado como terminado porque se ha configurado el tiempo en 2, comienza el proceso de apagado del Pod.<ol><li>Si uno de los contenedores del Pod ha definido un <a href=/es/docs/concepts/containers/container-lifecycle-hooks/#hook-details>preStop hook</a>, se invoca dentro del contenedor. Si el hook <code>preStop</code> todavía se está ejecutando después de que expire el período de gracia, el paso 2 se invoca con un pequeño período de gracia extendido (2s).</li><li>El contenedor recibe la señal TERM. Tenga en cuenta que no todos los contenedores en el Pod recibirán la señal TERM al mismo tiempo y cada uno puede requerir un hook <code>preStop</code> si el orden en el que se cierra es importante.</li></ol></li><li>(simultáneo con 3) Pod se elimina de la lista de endponts del servicio, y ya no se considera parte del conjunto de Pods en ejecución para controladores de replicación. Los Pods que se apagan lentamente no pueden continuar sirviendo el tráfico ya que los balanceadores de carga (como el proxy de servicio) los eliminan de sus rotaciones.</li><li>Cuando expira el período de gracia, todos los procesos que todavía se ejecutan en el Pod se eliminan con SIGKILL.</li><li>El Kubelet terminará de eliminar el Pod en el servidor API configurando el período de gracia 0 (eliminación inmediata). El Pod desaparece de la API y ya no es visible desde el cliente.</li></ol><p>Por defecto, todas las eliminaciones se realizan correctamente en 30 segundos. El comando <code>kubectl delete</code> admite la opción<code>--grace-period = &lt;seconds></code>que permite al usuario anular el valor predeterminado y especificar su propio valor. El valor <code>0</code> <a href=/es/docs/concepts/workloads/pods/pod/#forzar-destrucci%C3%B3n-de-pods>forzar eliminación</a> del Pod.
Debe especificar un indicador adicional <code>--force</code> junto con<code> --grace-period = 0</code> para realizar eliminaciones forzadas.</p><h3 id=forzar-destrucción-de-pods>Forzar destrucción de Pods</h3><p>La eliminación forzada de un Pod se define como la eliminación de un Pod del estado del clúster y etcd inmediatamente. Cuando se realiza una eliminación forzada, el apiserver no espera la confirmación del kubelet de que el Pod ha finalizado en el nodo en el que se estaba ejecutando. Elimina el Pod en la API inmediatamente para que se pueda crear un nuevo Pod con el mismo nombre. En el nodo, los Pods que están configurados para terminar de inmediato recibirán un pequeño período de gracia antes de ser forzadas a matar.</p><p>Estas eliminaciones pueden ser potencialmente peligrosas para algunos Pods y deben realizarse con precaución. En el caso de Pods de StatefulSets, consulte la documentación de la tarea para <a href=/docs/tasks/run-application/force-delete-stateful-set-pod/>eliminando Pods de un StatefulSet</a>.</p><h2 id=modo-privilegiado-para-pods>Modo privilegiado para Pods</h2><p>Cualquier contenedor en un Pod puede habilitar el modo privilegiado, utilizando el indicador <code>privilegiado</code> en el <a href=/docs/tasks/configure-pod-container/security-context/>contexto de seguridad</a> de la especificación del contenedor. Esto es útil para contenedores que desean usar capacidades de Linux como manipular la pila de red y acceder a dispositivos. Los procesos dentro del contenedor obtienen casi los mismos privilegios que están disponibles para los procesos fuera de un contenedor. Con el modo privilegiado, debería ser más fácil escribir complementos de red y volumen como Pods separados que no necesitan compilarse en el kubelet.</p><blockquote class="note callout"><div><strong>Nota:</strong> El <a class=glossary-tooltip title="El Container Runtime, entorno de ejecución de un contenedor, es el software responsable de ejecutar contenedores." data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label="runtime de contenedores">runtime de contenedores</a> debe admitir el concepto de un contenedor privilegiado para que esta configuración sea relevante.</div></blockquote><h2 id=api>API</h2><p>Pod es un recurso de nivel superior en la API REST de Kubernetes.
La definición de <a href=/docs/reference/generated/kubernetes-api/v1.21/#pod-v1-core>objeto de API Pod</a>
describe el objeto en detalle.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4e9b9cbc9776b12e7335c53da377c9c8>2 - Pod Preset</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.6 [alpha]</code></div><p>Esta página provee una descripción general de los PodPresets, los cuales son
los objetos que se utilizan para inyectar cierta información en los Pods en
el momento de la creación. Esta información puede incluir secretos, volúmenes,
montajes de volúmenes y variables de entorno.</p><h2 id=entendiendo-los-pod-presets>Entendiendo los Pod Presets</h2><p>Un PodPreset es un recurso de la API utilizado para poder inyectar requerimientos
adicionales de tiempo de ejecución en un Pod en el momento de la creación.
Se utilizan los <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>selectores de etiquetas</a>
para especificar los Pods a los que se aplica un PodPreset determinado.</p><p>El uso de un PodPreset permite a los autores de plantillas de Pods no tener que proporcionar
explícitamente toda la información de cada Pod. De esta manera, los autores de plantillas de
Pods que consuman un determinado servicio no tendrán que conocer todos los detalles de ese servicio.</p><h2 id=habilitando-un-podpreset-en-su-clúster>Habilitando un PodPreset en su clúster</h2><p>Con el fin de utilizar los Pod Presets en un clúster debe asegurarse de lo siguiente:</p><ol><li><p>Que se ha configurado el tipo de API <code>settings.k8s.io/v1alpha1/podpreset</code>. Esto se puede hacer,
por ejemplo, incluyendo <code>settings.k8s.io/v1alpha1=true</code> como valor de la opción <code>--runtime-config</code>
en el servidor API. En minikube se debe añadir el flag
<code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code> cuando el clúster
se está iniciando.</p></li><li><p>Que se ha habilitado el controlador de admisión <code>PodPreset</code>. Una forma de hacer esto es incluir
<code>PodPreset</code> como valor de la opción <code>--enable-admission-plugins</code> especificada
para el servidor API. En minikube se debe añadir el flag</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--extra-config<span style=color:#666>=</span>apiserver.enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset
</code></pre></div><p>cuando el clúster se está iniciando.</p></li></ol><h2 id=cómo-funciona>Cómo funciona</h2><p>Kubernetes provee un controlador de admisión (<code>PodPreset</code>) que, cuando está habilitado,
aplica los Pod Presets a las peticiones de creación de Pods entrantes.
Cuando se realiza una solicitud de creación de Pods, el sistema hace lo siguiente:</p><ol><li>Obtiene todos los <code>PodPresets</code> disponibles para usar.</li><li>Verifica si los selectores de etiquetas de cualquier <code>PodPreset</code> correspondan
con las etiquetas del Pod que se está creando.</li><li>Intenta fusionar los diversos recursos definidos por el <code>PodPreset</code> dentro del Pod
que se está creando.</li><li>Si se llegase a producir un error al intentar fusionar los recursos dentro del Pod,
lanza un evento que documente este error, luego crea el Pod <em>sin</em> ningún recurso que se
inyecte desde el <code>PodPreset</code>.</li><li>Escribe una nota descriptiva de la especificación de Pod modificada resultante para
indicar que ha sido modificada por un <code>PodPreset</code>. La nota descriptiva presenta la forma
<code>podpreset.admission.kubernetes.io/podpreset-&lt;pod-preset name>: "&lt;resource version>"</code>.</li></ol><p>Cada Pod puede ser correspondido por cero o más Pod Presets; y cada <code>PodPreset</code> puede ser
aplicado a cero o más Pods. Cuando se aplica un <code>PodPreset</code> a una o más Pods, Kubernetes
modifica la especificación del Pod. Para los cambios a <code>env</code>, <code>envFrom</code>, y <code>volumeMounts</code>,
Kubernetes modifica la especificación del Container para todos los Containers en el Pod;
para los cambios a <code>volumes</code>, Kubernetes modifica la especificación del Pod.</p><blockquote class="note callout"><div><strong>Nota:</strong><p>Un Pod Preset es capaz de modificar los siguientes campos en las especificaciones de un Pod
en caso de ser necesario:</p><ul><li>El campo <code>.spec.containers</code>.</li><li>El campo <code>.spec.initContainers</code></li></ul></div></blockquote><h3 id=deshabilitar-un-pod-preset-para-un-pod-específico>Deshabilitar un Pod Preset para un Pod específico</h3><p>Puede haber casos en los que se desee que un Pod no se vea alterado por ninguna posible
modificación del Pod Preset. En estos casos, se puede añadir una observación en el Pod
<code>.spec</code> de la siguiente forma: <code>podpreset.admission.kubernetes.io/exclude: "true"</code>.</p><h2 id=siguientes-pasos>Siguientes pasos</h2><p>Ver <a href=/docs/tasks/inject-data-application/podpreset/>Inyectando datos en un Pod usando PodPreset</a></p><p>Para más información sobre los detalles de los trasfondos, consulte la <a href=https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md>propuesta de diseño de PodPreset</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>3 - Containers Efímeros</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p>Esta página proporciona una descripción general de los Containers efímeros: un tipo especial de Container
que se ejecuta temporalmente en un <a class=glossary-tooltip title="El objeto más pequeño y simple de Kubernetes. Un Pod es la unidad mínima de computación en Kubernetes y representa uno o más contenedores ejecutándose en el clúster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> ya existente para cumplir las
acciones iniciadas por el usuario, como por ejemplo, la solución de problemas. En vez de ser utilizadas para
crear aplicaciones, los Containers efímeros se utilizan para examinar los servicios.</p><blockquote class="warning callout"><div><strong>Advertencia:</strong> Los Containers efímeros se encuentran en una fase alfa inicial y no son aptos para clústers
de producción. Es de esperar que esta característica no funcione en algunas situaciones, por
ejemplo, al seleccionar los Namespaces de un Container. De acuerdo con la <a href=/docs/reference/using-api/deprecation-policy/>Política de
Deprecación de Kubernetes</a>, esta característica
alfa puede variar significativamente en el futuro o ser eliminada por completo.</div></blockquote><h2 id=entendiendo-los-containers-efímeros>Entendiendo los Containers efímeros</h2><p><a class=glossary-tooltip title="El objeto más pequeño y simple de Kubernetes. Un Pod es la unidad mínima de computación en Kubernetes y representa uno o más contenedores ejecutándose en el clúster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> son el componente fundamental de las
aplicaciones de Kubernetes. Puesto que los Pods están previstos para ser desechables
y reemplazables, no se puede añadir un Container a un Pod una vez creado. Sin embargo, por lo
general se eliminan y se reemplazan los Pods de manera controlada utilizando
<a class=glossary-tooltip title="Un objeto API que gestiona una aplicación replicada." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployments>Deployments</a>.</p><p>En ocasiones es necesario examinar el estado de un Pod existente, como por ejemplo,
para poder solucionar un error difícil de reproducir. Puede ejecutar en estos casos
un Container efímero en un Pod ya existente para examinar su estado y para ejecutar
comandos de manera arbitraria.</p><h3 id=qué-es-un-container-efímero>Qué es un Container efímero?</h3><p>Los Containers efímeros se diferencian de otros Containers en que no garantizan ni los
recursos ni la ejecución, y en que nunca se reiniciarán automáticamente, de modo que no
son aptos para la construcción de aplicaciones. Los Containers efímeros se describen
usando la misma <a href=/docs/reference/generated/kubernetes-api/v1.21/#container-v1-core>ContainerSpec</a> que los Containers regulares, aunque muchos campos son
incompatibles y no están habilitados para los Containers efímeros.</p><ul><li>Los Containers efímeros no pueden tener puertos, por lo que campos como <code>ports</code>,
<code>livenessProbe</code>, <code>readinessProbe</code> no están habilitados.</li><li>Las asignaciones de recursos del Pod son inmutables, por lo que no esta habilitado
configurar "resources".</li><li>Para obtener una lista completa de los campos habilitados, consulte la documentación
de referencia [EphemeralContainer] (/docs/reference/generated/kubernetes-api/v1.21/#ephemeralcontainer-v1-core).</li></ul><p>En vez de añadirlos de forma directa al <code>pod.spec</code>, los Containers efímeros se crean usando un
controlador especial de la API, <code>ephemeralcontainers</code>, por lo tanto no es posible añadir un
Container efímero utilizando <code>kubectl edit</code>.</p><p>Al igual en el caso de los Containers regulares, no se puede modificar o remover un Container
efímero después de haberlo agregado a un Pod.</p><h2 id=casos-de-uso-para-los-containers-efímeros>Casos de uso para los Containers efímeros</h2><p>Los Containers efímeros resultan útiles para la solución interactiva de incidencias cuando
<code>kubectl exec</code> es insuficiente tanto porque un container se ha caído, como porque la imagen de un
Container no incluye las utilidades de depuración.</p><p>En particular, las <a href=https://github.com/GoogleContainerTools/distroless>imágenes distroless</a>
le permiten desplegar imágenes de Containers mínimos que disminuyen la superficie de ataque
y la exposición a errores y vulnerabilidades. Ya que las imágenes distroless no contienen un
shell ni ninguna utilidad de depuración, resulta difícil solucionar los problemas de las imágenes
distroless usando solamente <code>kubectl exec</code>.</p><p>Cuando utilice Containers efímeros, es conveniente habilitar el <a href=/docs/tasks/configure-pod-container/share-process-namespace/>proceso Namespace de uso
compartido</a> para poder ver los
procesos en otros containers.</p><h3 id=ejemplos>Ejemplos</h3><blockquote class="note callout"><div><strong>Nota:</strong> Los ejemplos de esta sección requieren que los <code>EphemeralContainers</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature
gate</a> estén habilitados
y que tanto el cliente como el servidor de Kubernetes tengan la version v1.16 o posterior.</div></blockquote><p>En los ejemplos de esta sección muestran la forma en que los Containers efímeros se
presentan en la API. Los usuarios normalmente usarían un plugin <code>kubectl</code> para la solución
de problemas que automatizaría estos pasos.</p><p>Los Containers efímeros son creados utilizando el subrecurso <code>ephemeralcontainers</code> del Pod,
que puede ser visto utilizando <code>kubectl --raw</code>. En primer lugar describa el Container
efímero a añadir como una lista de <code>EphemeralContainers</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example-pod&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>: [{
        <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
            <span style=color:#b44>&#34;sh&#34;</span>
        ],
        <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>,
        <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>: <span style=color:#b44>&#34;IfNotPresent&#34;</span>,
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;debugger&#34;</span>,
        <span style=color:green;font-weight:700>&#34;stdin&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
        <span style=color:green;font-weight:700>&#34;tty&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
        <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>: <span style=color:#b44>&#34;File&#34;</span>
    }]
}
</code></pre></div><p>Para actualizar los Containers efímeros de los <code>example-pod</code> en ejecución:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl replace --raw /api/v1/namespaces/default/pods/example-pod/ephemeralcontainers  -f ec.json
</code></pre></div><p>Esto devolverá una nueva lista de Containers efímeros:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
   <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
   <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,
   <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-pod&#34;</span>,
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,
      <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>:<span style=color:#b44>&#34;/api/v1/namespaces/default/pods/example-pod/ephemeralcontainers&#34;</span>,
      <span style=color:green;font-weight:700>&#34;uid&#34;</span>:<span style=color:#b44>&#34;a14a6d9b-62f2-4119-9d8e-e2ed6bc3a47c&#34;</span>,
      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;15886&#34;</span>,
      <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>:<span style=color:#b44>&#34;2019-08-29T06:41:42Z&#34;</span>
   },
   <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>:[
      {
         <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;debugger&#34;</span>,
         <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;busybox&#34;</span>,
         <span style=color:green;font-weight:700>&#34;command&#34;</span>:[
            <span style=color:#b44>&#34;sh&#34;</span>
         ],
         <span style=color:green;font-weight:700>&#34;resources&#34;</span>:{

         },
         <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>:<span style=color:#b44>&#34;File&#34;</span>,
         <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>:<span style=color:#b44>&#34;IfNotPresent&#34;</span>,
         <span style=color:green;font-weight:700>&#34;stdin&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>,
         <span style=color:green;font-weight:700>&#34;tty&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>
      }
   ]
}
</code></pre></div><p>Se puede ver el estado del Container efímero creado usando <code>kubectl describe</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod example-pod
</code></pre></div><pre><code>...
Ephemeral Containers:
  debugger:
    Container ID:  docker://cf81908f149e7e9213d3c3644eda55c72efaff67652a2685c1146f0ce151e80f
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:9f1003c480699be56815db0f8146ad2e22efea85129b5b5983d0e0fb52d9ab70
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sh
    State:          Running
      Started:      Thu, 29 Aug 2019 06:42:21 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>Se puede conectar al nuevo Container efímero usando <code>kubectl attach</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl attach -it example-pod -c debugger
</code></pre></div><p>Si el proceso Namespace de uso compartido está habilitado, se pueden visualizar los procesos de todos los Containers de ese Pod.
Por ejemplo, después de haber conectado, ejecute <code>ps</code> en el debugger del container:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxww
</code></pre></div><p>La respuesta es semejante a:</p><pre><code>PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    6 root      0:00 nginx: master process nginx -g daemon off;
   11 101       0:00 nginx: worker process
   12 101       0:00 nginx: worker process
   13 101       0:00 nginx: worker process
   14 101       0:00 nginx: worker process
   15 101       0:00 nginx: worker process
   16 101       0:00 nginx: worker process
   17 101       0:00 nginx: worker process
   18 101       0:00 nginx: worker process
   19 root      0:00 /pause
   24 root      0:00 sh
   29 root      0:00 ps auxww
</code></pre></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/es/docs/home/>Home</a>
<a class=text-white href=/es/blog/>Blog</a>
<a class=text-white href=/es/partners/>Partners</a>
<a class=text-white href=/es/community/>Comunidad</a>
<a class=text-white href=/es/case-studies/>Casos de éxito</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Los autores de Kubernetes | Documentación distribuida bajo <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Todos los derechos reservados. The Linux Foundation tiene marcas registradas y utiliza marcas registradas. Para obtener una lista de marcas registradas por The Linux Foundation, visita <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script></body></html>